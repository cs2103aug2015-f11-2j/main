# A0126120B
###### bin\app\view\css\base.css
``` css

.commandInput {
	-fx-background-radius: 0.0;
}

/* Default background color for items */
.list-cell {
	-fx-background-color: #FCFCFC;
	-fx-padding: 0.0px;
}

.list-view {
	-fx-border-width: 0.0px 0.0 1.0px 0.0px;
	-fx-padding: 0px;
}

.textViewTextArea {
	-fx-background-radius: 0.0;
}

.textViewTextArea .content {
	-fx-background-radius: 0.0;
}

.header {
	-fx-font-family: "Segoe UI Semibold";
	-fx-font-size: 16px;
	-fx-border-width: 0 0 2px 0;
}

/* Individual task items. */
.taskItem {
	-fx-border-width: 0.0 0.0 1.0px 3px;
}

.taskItemTime, .taskItemDate {
	-fx-padding: 2px;
	-fx-background-radius: 3px;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 12px;
}

.taskItem.taskDateLabel {
	-fx-font-size: 16px;
	-fx-padding: 2px 10px 2px 10px;
}

/* Begin completed tasks */
.taskItem.completed {
	-fx-opacity: 0.7;
}

.taskItem.completed .taskName .text {
	-fx-strikethrough: true;
}
/* End completed tasks */

/* Begin priority indicators */
.taskItem.priorityHigh .taskItemLine1, .taskItem.priorityHigh .taskItemLine2 {
	-fx-stroke: #F44336;
}

.taskItem.priorityMedium .taskItemLine1, .taskItem.priorityMedium .taskItemLine2 {
	-fx-stroke: #FFC107;
}

.taskItem.priorityLow .taskItemLine1, .taskItem.priorityLow .taskItemLine2 {
	-fx-stroke: #4CAF50;
}

.taskItem.priorityHigh .priorityImage {
	-fx-image: url("../images/priority_high_icon.png");
}

.taskItem.priorityMedium .priorityImage {
	-fx-image: url("../images/priority_medium_icon.png");
}

.taskItem.priorityLow .priorityImage {
	-fx-image: url("../images/priority_low_icon.png");
}
/* End priority indicators */

.commandInput {
	-fx-background-radius: 0.0;
}

.infoView {
	-fx-background-color: linear-gradient(from 0.0px 0.0px to 0.0px 6.0px, #DDDDDD, #FCFCFC);
}

.infoView .infoContent, .infoView .infoDate, .infoView .infoPriority, 
.infoView .infoDescription, .infoView .infoCommand, 
.infoView .infoRequired, .infoView .infoOptional {
	-fx-font-family: "Segoe UI Semibold";
}
```
###### bin\app\view\css\theme_dark.css
``` css

.list-view {
	-fx-background-color: #323A43;
	-fx-border-color: #101010 transparent #101010 transparent;
}

.list-cell {
	-fx-background-color: #323A43;
}

.list-cell .label {
	-fx-text-fill: #FDFDFD; 
}

.header {
	-fx-background-color: #292E39;
	-fx-text-fill: #FDFDFD;
	-fx-border-color: transparent transparent #151515 transparent;
}

.taskItem.completed {
	-fx-background-color: #314937;
}

.taskItem.completed .taskItemDate, .taskItem.completed .taskItemTime {
	-fx-background-color: #9599a2;
}

/* Begin task items. */
.taskItem {
	-fx-background-color: #323A43;
}

.taskItem {
	-fx-border-color: transparent transparent #151515 transparent;
}

.taskItem.purple {
	-fx-border-color: transparent transparent #151515 #35294F;
}

.taskItem.taskDateLabel.purple {
	-fx-background-color: #35294F;
}

.taskItem.blue {
	-fx-border-color: transparent transparent #151515 #233E4B;
}

.taskItem.taskDateLabel.blue {
	-fx-background-color: #233E4B;
}

.taskItem.green {
	-fx-border-color: transparent transparent #151515 #234B39;
}

.taskItem.taskDateLabel.green {
	-fx-background-color: #234B39;
}

.taskItem.yellow {
	-fx-border-color: transparent transparent #151515 #503E25;
}

.taskItem.taskDateLabel.yellow {
	-fx-background-color: #503E25;
}

.taskItem.orange {
	-fx-border-color: transparent transparent #151515 #502B25;
}

.taskItem.taskDateLabel.orange {
	-fx-background-color: #502B25;
}

.taskItem.red {
	-fx-border-color: transparent transparent #151515 #371010;
}

.taskItem.taskDateLabel.red {
	-fx-background-color: #371010;
}

.taskItem.pink {
	-fx-border-color: transparent transparent #151515 #43223f;
}

.taskItem.taskDateLabel.pink {
	-fx-background-color: #43223f;
}
/* End task items. */

.taskItemTime, .taskItemDate {
	-fx-text-fill: #fcfcfc;
}

.taskItemTime {
	-fx-background-color: #386ee1;
}

.taskItemDate {
	-fx-background-color: #6b42e0;
}

.list-view .listViewTitle, .list-view .listViewNoTasks, .list-view .listViewInfo1, .list-view .listViewInfo2 {
	-fx-text-fill: #FDFDFD; 
}

.statusBar {
	-fx-background-color: #292E39;
}

.commandInput {
	-fx-background-color: #1C1F26;
	-fx-text-fill: #FDFDFD;
}

.textViewTextArea {
	-fx-background-color: #323A43;
	-fx-text-fill: #FDFDFD;
}

.textViewTextArea .content {
	-fx-background-color: #323A43;
}

.taskItemLines .taskItemLine1, .taskItemLines .taskItemLine2 {
	-fx-stroke: #151515;	
}

/* Status bar */
.statusBar.success {
	-fx-text-fill: #78CA5C;
}

.statusBar.error {
	-fx-text-fill: #F64641;
}

.statusBar.info {
	-fx-text-fill: #FDFDFD;
}
/* End status bar */

.infoView {
	-fx-background-color: linear-gradient(from 0.0px 0.0px to 0.0px 5.0px, #14181D, #292E39);
}

.infoView .text {
	-fx-fill: #FDFDFD;
}

.infoView .infoDate, .infoView .infoPriority {
	-fx-fill: #008ED6;
}

.infoView .infoCommand {
	-fx-fill: #EA7640;
}

.infoView .infoRequired {
	-fx-fill: #008ED6;
}

.infoView .infoOptional {
	-fx-fill: #A4A4A4;
}
```
###### bin\app\view\css\theme_light.css
``` css

.list-view {
	-fx-background-color: #FCFCFC;
	-fx-border-color: transparent transparent #CCCCCC transparent;
}

.list-cell {
	-fx-background-color: #FCFCFC;
}

.header {
	-fx-border-color: transparent transparent #606060 transparent;
}

.taskItem.completed {
	-fx-background-color: #def5df;
}

.taskItem.completed .taskItemDate, .taskItem.completed .taskItemTime {
	-fx-background-color: #a3a7b1;
}

/* Begin task items. */
.taskItem {
	-fx-background-color: #FCFCFC;
}

.taskItem {
	-fx-border-color: transparent transparent #CCCCCC transparent;
}

.taskItem.purple {
	-fx-border-color: transparent transparent #CCCCCC #c4c4e1;
}

.taskItem.taskDateLabel.purple {
	-fx-background-color: #c4c4e1;
	-fx-border-color: transparent transparent #9292de #c4c4e1;
}

.taskItem.blue {
	-fx-border-color: transparent transparent #CCCCCC #bacee5;
}

.taskItem.taskDateLabel.blue {
	-fx-background-color: #bacee5;
	-fx-border-color: transparent transparent #7faee3 #bacee5;
}

.taskItem.green {
	-fx-border-color: transparent transparent #CCCCCC #afdab6;
}

.taskItem.taskDateLabel.green {
	-fx-background-color: #afdab6;
	-fx-border-color: transparent transparent #73d884 #afdab6;
}

.taskItem.yellow {
	-fx-border-color: transparent transparent #CCCCCC #f4e9c0;
}

.taskItem.taskDateLabel.yellow {
	-fx-background-color: #f4e9c0;
	-fx-border-color: transparent transparent #f2da80 #f4e9c0;
}

.taskItem.orange {
	-fx-border-color: transparent transparent #CCCCCC #f4dcb9;
}

.taskItem.taskDateLabel.orange {
	-fx-background-color: #f4dcb9;
	-fx-border-color: transparent transparent #f0c17e #f4dcb9;
}

.taskItem.red {
	-fx-border-color: transparent transparent #CCCCCC #dfa9ac;
}

.taskItem.taskDateLabel.red {
	-fx-background-color: #dfa9ac;
	-fx-border-color: transparent transparent #df7c82 #dfa9ac;
}

.taskItem.pink {
	-fx-border-color: transparent transparent #CCCCCC #edcedb;
}

.taskItem.taskDateLabel.pink {
	-fx-background-color: #edcedb;
	-fx-border-color: transparent transparent #ec8bb5 #edcedb;
}

/* End task items. */

.taskItemLines .taskItemLine1, .taskItemLines .taskItemLine2 {
	-fx-stroke: #CCCCCC;	
}

.taskItemTime, .taskItemDate {
	-fx-text-fill: #fcfcfc;
}

.taskItemTime {
	-fx-background-color: #4b7adf;
}

.taskItemDate {
	-fx-background-color: #7854df;
}

/* Status bar */
.statusBar.success {
	-fx-text-fill: green;
}

.statusBar.error {
	-fx-text-fill: red;
}

.statusBar.info {
	-fx-text-fill: black;
}
/* End status bar */

.infoView .infoDate, .infoView .infoPriority {
	-fx-fill: #0056BD;
}

.infoView .infoDescription, .infoView .infoContent {
	-fx-fill: #232323;
}

.infoView .infoCommand {
	-fx-fill: #E35B2C;
}

.infoView .infoRequired {
	-fx-fill: #0056BD;
}

.infoView .infoOptional {
	-fx-fill: #666666;
}
```
###### src\app\constants\TaskConstants.java
``` java
	// Enum values for the different priority levels
	public enum Priority {
		HIGH, MEDIUM, LOW, NONE;
	}

```
###### src\app\constants\ViewConstants.java
``` java
	// Style classes for the different statusbar statuses
	public static String STATUS_STYLE_SUCCESS = "success";
	public static String STATUS_STYLE_ERROR = "error";
	public static String STATUS_STYLE_INFO = "info";
	
```
###### src\app\constants\ViewConstants.java
``` java
	// Style classes for task item colors
	public static String ITEM_PURPLE = "purple";
	public static String ITEM_BLUE = "blue";
	public static String ITEM_GREEN = "green";
	public static String ITEM_YELLOW = "yellow";
	public static String ITEM_ORANGE = "orange";
	public static String ITEM_RED = "red";
	public static String ITEM_PINK = "pink";

```
###### src\app\constants\ViewConstants.java
``` java
	// THEME command
	// Resource locations for the theme CSS files.
	public static String THEME_LIGHT_CSS = Main.class.getResource("view/css/theme_light.css").toExternalForm();
	public static String THEME_DARK_CSS = Main.class.getResource("view/css/theme_dark.css").toExternalForm();
	public static String THEME_LIGHT = "light";
	public static String THEME_DARK = "dark";
	public static String MESSAGE_AVAILABLE_THEMES = "Available themes: light, dark";
	public static String MESSAGE_CURRENT_THEME = "Current theme: %1$s";
	
```
###### src\app\constants\ViewConstants.java
``` java
	// ADD command
	public static String MESSAGE_ADD = "Added task: %1$s";
	public static String ERROR_ADD = "Error adding task: %1$s";
	public static String ERROR_ADD_NO_TASK = "No task specified";
	
```
###### src\app\constants\ViewConstants.java
``` java
	// Enum values for the different statusbar statuses
	public enum StatusType {
		SUCCESS, ERROR, INFO;
	}
	
```
###### src\app\constants\ViewConstants.java
``` java
	// Enum values for the different primary views
	public enum ViewType {
		TASK_LIST, TEXT_VIEW;
	}
	
```
###### src\app\constants\ViewConstants.java
``` java
	public enum ScrollDirection {
		UP, DOWN;
	}
	
```
###### src\app\constants\ViewConstants.java
``` java
	public enum ActionType {
		SCROLL_TASK_LIST_TO, SCROLL_TASK_LIST_TO_TOP, EXIT;
	}
	
```
###### src\app\constants\ViewConstants.java
``` java
	public static Queue<String> getItemColorsQueue() {
		Queue<String> queue = new LinkedList<String>();
		queue.add(ITEM_PURPLE);
		queue.add(ITEM_BLUE);
		queue.add(ITEM_GREEN);
		queue.add(ITEM_YELLOW);
		queue.add(ITEM_ORANGE);
		queue.add(ITEM_RED);
		queue.add(ITEM_PINK);
		return queue;
	}
}
```
###### src\app\Main.java
``` java
public class Main extends Application {

	private Stage primaryStage;
	private ViewManager viewManager;
	
	private final int MIN_WIDTH = 600;
	private final int MIN_HEIGHT = 300;

	@Override
	public void start(Stage stage) {
		AppStorage.getInstance(); // initialize config/storage/log files
		initializeStage(stage);
		initializeViewManager();
		
		// Execute commands passed to the program
		List<String> args = getParameters().getRaw();
		for (String command : args) {
			viewManager.sendCommandToInput(command);
		}
	}

	public static void main(String[] args) {
		launch(args);
	}

	/**
	 * Initializes the ViewManager
	 */
	private void initializeViewManager() {
		try {
			FXMLLoader loader = new FXMLLoader();
			loader.setLocation(Main.class.getResource("view/fxml/RootView.fxml"));
			BorderPane rootLayout = loader.load();
			viewManager = loader.getController();
			viewManager.initialize(primaryStage, rootLayout);
		} catch (IOException e) {
			LogHelper.getInstance().getLogger().severe(e.getMessage());
		}
	}

	/**
	 * Initializes the stage (window) parameters, such as: title, minimum
	 * width/height.
	 * 
	 * @param stage The stage (window) to set parameters for.
	 */
	private void initializeStage(Stage stage) {
		primaryStage = stage;
		primaryStage.setTitle("Next :: your next-gen todo list");
		primaryStage.setMinWidth(MIN_WIDTH);
		primaryStage.setMinHeight(MIN_HEIGHT);
	}
}
```
###### src\app\model\Task.java
``` java
	public Task(Command cmd) {
		id = UUID.randomUUID();
		name = cmd.getContent();
		startDate = cmd.getStartDate();
		endDate = cmd.getEndDate();
		priority = cmd.getPriority();
		removeField = cmd.getRemoveField();
		isCompleted = false;
	}

```
###### src\app\model\Task.java
``` java
	public boolean isFloating() {
		return (getStartDate() == null && getEndDate() == null);
	}

	public boolean isDeadline() {
		return (getStartDate() == null && getEndDate() != null);
	}

	public boolean isEvent() {
		return (getStartDate() != null && getEndDate() != null);
	}

	public LocalDateTime getSortKey() {
		if (isDeadline()) {
			return getEndDate();
		} else if (isEvent()) {
			return getStartDate();
		}
		return null;
	}

	private LocalDateTime getSecondarySortKey() {
		if (isEvent()) {
			return getEndDate();
		}
		return null;
	}

	/**
	 * Compares this task with the one specified. The sorting order is as
	 * follows:
	 * 
	 * (1) Floating tasks, (2) Start date if not null, (3) End date if not null.
	 * 
	 * For similar dates, the subsequent sorting order is used:
	 * 
	 * (1) Priority is higher, (2) Name by lexicographical ordering
	 */
	@Override
	public int compareTo(Task task) {
		LocalDateTime thisSortKey = getSortKey();
		LocalDateTime taskSortKey = task.getSortKey();
		LocalDateTime thisSecondarySortKey = getSecondarySortKey();
		LocalDateTime taskSecondarySortKey = task.getSecondarySortKey();
		int result = 0;

		// Floating is always < non-floating
		if (isFloating() && !task.isFloating()) {
			return -1;
		} else if (!isFloating() && task.isFloating()) {
			return 1;
		} else if (thisSortKey != null && taskSortKey != null) {
			// Compare primary date sort keys (events: startDate, deadlines:
			// endDate), if similar, compare secondary date sort keys (events:
			// endDate, deadlines: null)
			result = thisSortKey.compareTo(taskSortKey);
			if (result == 0 && thisSecondarySortKey != null && taskSecondarySortKey != null) {
				result = thisSecondarySortKey.compareTo(taskSecondarySortKey);
			}
		}

		// Compare priority
		if (result == 0) {
			result = getPriority().compareTo(task.getPriority());
		}

		// Compare names
		if (result == 0) {
			result = getName().compareToIgnoreCase(task.getName());
		}

		return result;
	}
}
```
###### src\app\model\TaskCell.java
``` java
	public String getLabel() {
		// if date is today or tomorrow, append the relevant string
		String relativeText = "";
		if (LocalDate.now().isEqual(labelDate)) {
			relativeText = " (Today)";
		} else if (LocalDate.now().plusDays(1).isEqual(labelDate)) {
			relativeText = " (Tomorrow)";
		}
		
		// If date.year == current year, omit the year from the label
		DateTimeFormatter dateFormatter = null;
		if (labelDate.getYear() == LocalDate.now().getYear()) {
			dateFormatter = DateTimeFormatter.ofPattern(DATE_PATTERN);
		} else {
			dateFormatter = DateTimeFormatter.ofPattern(DATE_PATTERN_WITH_YEAR);
		}
		
		String label = labelDate.format(dateFormatter) + relativeText;
		return label;
	}

}
```
###### src\app\model\TaskList.java
``` java
	public TaskList() {
		taskList = FXCollections.observableArrayList();
	}

```
###### src\app\model\TaskList.java
``` java
	// Constructor to make a copy from another TaskList
	public TaskList(TaskList taskList) {
		this.taskList = FXCollections.observableArrayList(taskList.getTaskList());
	}

	public ObservableList<Task> getTaskList() {
		return taskList;
	}

	public void setAll(TaskList tasks) {
		taskList.setAll(tasks.getTaskList());
	}

	public void addTask(Task task) {
		taskList.add(task);
	}

	/**
	 * Sorts this task list in-place.
	 */
	public void sort() {
		taskList.sort((t1, t2) -> t1.compareTo(t2));
	}

```
###### src\app\model\ViewState.java
``` java
	// Clone state
	public ViewState(ViewState state) {
		header = state.getHeader();
		statusMessage = state.getStatusMessage();
		statusType = state.getStatusType();
		activeView = state.getActiveView();
		taskList = state.getTaskList();
		textArea = state.getTextArea();
		theme = state.getTheme();
		actions = state.getActions();
	}

```
###### src\app\model\ViewState.java
``` java
	public ViewState() {
		actions = new ArrayList<Action>();
	}

```
###### src\app\model\ViewState.java
``` java
	public void mergeWith(ViewState newState) {
		if (newState.getHeader() != null) {
			header = newState.getHeader();
		}
		if (newState.getActiveView() != null) {
			activeView = newState.getActiveView();
		}
		if (newState.getTaskList() != null) {
			taskList = newState.getTaskList();
		}
		if (newState.getTextArea() != null) {
			textArea = newState.getTextArea();
		}
		if (newState.getTheme() != null) {
			theme = newState.getTheme();
		}
		mergeStatus(newState);
		// Always replace actions, even if empty. Essentially this acts as a
		// reset if no new actions are specified.
		actions = newState.getActions();
	}
	
```
###### src\app\model\ViewState.java
``` java
	public void mergeStatus(ViewState newState) {
		if (newState.getStatusMessage() != null) {
			statusMessage = newState.getStatusMessage();
		}
		if (newState.getStatusType() != null) {
			statusType = newState.getStatusType();
		}
	}

```
###### src\app\model\ViewState.java
``` java
	public void setStatus(String message) {
		statusMessage = message;
		statusType = StatusType.INFO;
	}

```
###### src\app\model\ViewState.java
``` java
	public void setStatus(StatusType type, String message) {
		statusMessage = message;
		statusType = type;
	}

```
###### src\app\parser\CommandParser.java
``` java
	static {
		allKeywords = new ArrayList<String>();
		allKeywords.addAll(START_DATE_KEYWORDS);
		allKeywords.addAll(END_DATE_KEYWORDS);
		allKeywords.addAll(PRIORITY_KEYWORDS);

		allSearchKeywords = new ArrayList<String>();
		allSearchKeywords.addAll(SEARCH_START_DATE_KEYWORDS);
		allSearchKeywords.addAll(SEARCH_END_DATE_KEYWORDS);
		allSearchKeywords.addAll(SEARCH_START_DATERANGE_KEYWORDS);
		allSearchKeywords.addAll(PRIORITY_KEYWORDS);
		allSearchKeywords.addAll(DISPLAY_TYPE_KEYWORDS);

		displayTypes = new ArrayList<String>();
		displayTypes.addAll(DISPLAY_COMPLETED);
		displayTypes.addAll(DISPLAY_UNCOMPLETED);
		displayTypes.addAll(DISPLAY_ALL);
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Parses and sets search-related parameters for the Command object
	 * specified. This method should only be used for the search command.
	 * 
	 * The following parameters are set:
	 * 
	 * - Content, and if exists, startDate, endDate, priority, displayType.
	 * 
	 * @param cmd The Command object to set parameters for
	 */
	public static void parseSearch(Command cmd) {
		assert cmd != null;
		String[] arr = cmd.getContent().split(" ");
		ParserToken contentToken = new ParserToken();
		contentToken.setStart(0);

		ParserToken startToken = dateToken(arr, SEARCH_START_DATE_KEYWORDS, allSearchKeywords);
		ParserToken endToken = dateToken(arr, SEARCH_END_DATE_KEYWORDS, allSearchKeywords);
		ParserToken priorityToken = singleArgToken(arr, PRIORITY_KEYWORDS, PRIORITY_LEVELS);
		ParserToken displayToken = singleArgToken(arr, DISPLAY_TYPE_KEYWORDS, displayTypes);
		ParserToken nilDateToken = singleArgToken(arr, SEARCH_DATE_KEYWORDS, Arrays.asList(NONE_KEYWORD));

		// Daterange keywords for search: BETWEEN <date> AND <date>
		List<String> inclusiveEndKeywords = new ArrayList<String>(allSearchKeywords);
		inclusiveEndKeywords.addAll(SEARCH_END_DATERANGE_KEYWORDS);
		ParserToken rangeStartToken = dateToken(arr, SEARCH_START_DATERANGE_KEYWORDS, inclusiveEndKeywords);
		ParserToken rangeEndToken = dateToken(arr, SEARCH_END_DATERANGE_KEYWORDS, allSearchKeywords);

		// Try to parse daterange keywords
		String rangeStartDateString = Common.getStringFromArrayIndexRange(rangeStartToken.getStart() + 1,
				rangeStartToken.getEnd(), arr);
		String rangeEndDateString = Common.getStringFromArrayIndexRange(rangeEndToken.getStart() + 1,
				rangeEndToken.getEnd(), arr);
		LocalDateTime parsedRangeStart = DateParser.determineStartDate(rangeStartDateString);
		LocalDateTime parsedRangeEnd = DateParser.determineEndDate(rangeEndDateString, parsedRangeStart);

		// if exists, start & end date MUST be joined (between <date> and
		// <date>)
		if (!rangeStartToken.isEmpty() && !rangeEndToken.isEmpty()
				&& rangeStartToken.getEnd() + 1 != rangeEndToken.getStart()) {
			rangeStartToken.clear();
			rangeEndToken.clear();
		}

		// validate daterange
		clearIfCannotParse(rangeStartToken, parsedRangeStart);
		clearIfCannotParse(rangeEndToken, parsedRangeEnd);
		clearIfStartAfterEnd(rangeStartToken, rangeEndToken, parsedRangeStart, parsedRangeEnd);

		// if start/end tokens are not touching, then keep only the last
		if (!startToken.isEmpty() && !endToken.isEmpty() && startToken.getEnd() + 1 != endToken.getStart()) {
			if (endToken.getStart() > startToken.getEnd()) {
				startToken.clear();
			} else if (startToken.getStart() > endToken.getEnd()) {
				endToken.clear();
			}
		}
		// replace start and end tokens if a valid range is detected
		if (rangeStartToken.getStart() > startToken.getEnd() && rangeStartToken.getStart() > endToken.getEnd()) {
			startToken = rangeStartToken;
			endToken = rangeEndToken;
		}

		// Try to parse the dates detected.
		String startDateString = Common.getStringFromArrayIndexRange(startToken.getStart() + 1, startToken.getEnd(),
				arr);
		String endDateString = Common.getStringFromArrayIndexRange(endToken.getStart() + 1, endToken.getEnd(), arr);
		LocalDateTime parsedStart = DateParser.determineStartDate(startDateString);
		LocalDateTime parsedEnd = DateParser.determineEndDate(endDateString, parsedStart);

		// if start/end date is detected but cannot be parsed, we treat it as
		// part of the content instead.
		clearIfCannotParse(startToken, parsedStart);
		clearIfCannotParse(endToken, parsedEnd);

		// If start date > end date, the date range is invalid and is removed
		clearIfStartAfterEnd(startToken, endToken, parsedStart, parsedEnd);

		// Merge disjointed content tokens.
		updateContentEnd(contentToken, arr, priorityToken, displayToken, startToken, endToken, nilDateToken);

		
		if (!nilDateToken.isEmpty() && parsedStart == null && parsedEnd == null) {
			cmd.setFloatSearch(true);
		} else {
			nilDateToken.clear();
		}
		
		// Remove any tokens we merged over.
		clearTokensBeforeContent(contentToken, startToken, endToken, priorityToken, displayToken);
		if (startToken.isEmpty()) {
			parsedStart = null;
		}
		if (endToken.isEmpty()) {
			parsedEnd = null;
		}
		


		String content = Common.getStringFromArrayIndexRange(contentToken.getStart(), contentToken.getEnd(), arr);
		String priorityString = Common.getStringFromArrayIndexRange(priorityToken.getStart() + 1,
				priorityToken.getEnd(), arr);
		String typeString = Common.getStringFromArrayIndexRange(displayToken.getStart() + 1, displayToken.getEnd(),
				arr);
		Priority priority = determineSearchPriority(priorityString);
		DisplayType type = determineDisplayTypeSearch(typeString);

		// Sets the parsed parameters
		cmd.setContent(content);
		cmd.setPriority(priority);
		cmd.setStartDate(parsedStart);
		cmd.setEndDate(parsedEnd);
		cmd.setDisplayType(type);
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Parses and sets parameters for the Command object
	 * specified. The commandString of the specified Command object should
	 * already be set before calling this method.
	 * 
	 * By default, this method does not detect "date none" and "priority none" keywords
	 * 
	 * @param cmd The Command object to set parameters for
	 */
	public static void parseDatesAndPriority(Command cmd) {
		parseDatesAndPriority(cmd, false);
	}

	/**
	 * 
	 * Parses and sets parameters for the Command object
	 * specified. The commandString of the specified Command object should
	 * already be set before calling this method.
	 * 
	 * The following parameters are set:
	 * 
	 * - Content, and if exists, startDate, endDate, priority.
	 * 
	 * @param cmd The Command object to set parameters for
	 * @param removableParams Specifies if "date none" and "priority none" keywords should be accepted.
	 */
	public static void parseDatesAndPriority(Command cmd, boolean removableParams) {
		assert cmd != null;
		String[] arr = cmd.getContent().split(" ");
		ParserToken contentToken = new ParserToken();
		contentToken.setStart(0);

		ParserToken startToken = dateToken(arr, START_DATE_KEYWORDS, allKeywords);
		ParserToken endToken = dateToken(arr, END_DATE_KEYWORDS, allKeywords);
		ParserToken priorityToken = new ParserToken();
		priorityToken = singleArgToken(arr, PRIORITY_KEYWORDS, PRIORITY_LEVELS);

		// Try to parse the dates detected.
		String startDateString = Common.getStringFromArrayIndexRange(startToken.getStart() + 1, startToken.getEnd(),
				arr);
		String endDateString = Common.getStringFromArrayIndexRange(endToken.getStart() + 1, endToken.getEnd(), arr);
		LocalDateTime parsedStart = DateParser.determineStartDate(startDateString);
		LocalDateTime parsedEnd = DateParser.determineEndDate(endDateString, parsedStart);

		// if only start date exists, clear it
		if (!startToken.isEmpty() && endToken.isEmpty()) {
			startToken.clear();
		}

		// if exists, start & end date MUST be joined (from <date> to <date>)
		if (!startToken.isEmpty() && !endToken.isEmpty() && startToken.getEnd() + 1 != endToken.getStart()) {
			startToken.clear();
		}

		// if start/end date is detected but cannot be parsed, we treat it as
		// part of the content instead.
		clearIfCannotParse(startToken, parsedStart);
		clearIfCannotParse(endToken, parsedEnd);

		// If start date > end date, the date range is invalid and is removed
		clearIfStartAfterEnd(startToken, endToken, parsedStart, parsedEnd);

		// If called with removableParams == true, check for keyword "date none"
		// to see if the user wants to remove a date. Used for edit command.
		ParserToken removeDateToken = new ParserToken();
		if (removableParams) {
			removeDateToken = singleArgToken(arr, SEARCH_DATE_KEYWORDS, Arrays.asList(NONE_KEYWORD));
			if (!removeDateToken.isEmpty() && removeDateToken.getStart() > startToken.getEnd()
					&& removeDateToken.getStart() > endToken.getEnd()) {
				startToken.clear();
				endToken.clear();
			} else {
				removeDateToken.clear();
			}
		}

		// Merge disjointed content tokens.
		updateContentEnd(contentToken, arr, priorityToken, startToken, endToken, removeDateToken);

		// Remove any tokens we merged over.
		clearTokensBeforeContent(contentToken, startToken, endToken, priorityToken, removeDateToken);
		if (startToken.isEmpty()) {
			parsedStart = null;
		}
		if (endToken.isEmpty()) {
			parsedEnd = null;
		}

		// Builds the content from the token indexes
		// Parses the priority level if exists
		String content = Common.getStringFromArrayIndexRange(contentToken.getStart(), contentToken.getEnd(), arr);
		String priorityString = Common.getStringFromArrayIndexRange(priorityToken.getStart() + 1, priorityToken.getEnd(),
				arr);
		Priority priority = determinePriority(priorityString);

		if (removableParams) {
			if (!removeDateToken.isEmpty()) {
				cmd.addFieldToRemove(RemovableField.DATE);
			}
			if (priorityString.equalsIgnoreCase(NONE_KEYWORD)) {
				cmd.addFieldToRemove(RemovableField.PRIORITY);
			}
		}

		// Sets the parsed parameters
		cmd.setContent(content);
		cmd.setPriority(priority);
		cmd.setStartDate(parsedStart);
		cmd.setEndDate(parsedEnd);
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * @return A token describing a possible date string. The token is indicated
	 *         by a set of keywords to start searching from and breakpoints at
	 *         which to stop searching.
	 */
	private static ParserToken dateToken(String[] arr, List<String> keywords, List<String> breakpoints) {
		ParserToken token = new ParserToken();
		for (int i = 0; i < arr.length; i++) {
			if (keywords.contains(arr[i])) {
				token.setStart(i);
				int j = i + 1;
				while (j < arr.length && !breakpoints.contains(arr[j])) {
					token.setEnd(j);
					i = j++;
				}
			}
		}
		return token;
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * @return A token describing the last detected instance of a keyword
	 *         followed by a single argument.
	 */
	private static ParserToken singleArgToken(String[] arr, List<String> keywords, List<String> args) {
		ParserToken token = new ParserToken();
		for (int i = 0; i < arr.length; i++) {
			if (keywords.contains(arr[i])) {
				if (i + 1 < arr.length && args.contains(arr[i + 1])) {
					token.setStart(i);
					token.setEnd(i + 1);
					i++;
				}
			}
		}
		return token;
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Clear the tokens and parsed dates if start date > end date
	 */
	private static void clearIfStartAfterEnd(ParserToken startToken, ParserToken endToken, LocalDateTime startDate,
			LocalDateTime endDate) {
		if (startDate != null && endDate != null && !startDate.isBefore(endDate)) {
			startToken.clear();
			endToken.clear();
			startDate = endDate = null;
		}
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Clear token if the token exists yet the date cannot be parsed.
	 */
	private static void clearIfCannotParse(ParserToken token, LocalDateTime parsedDate) {
		if (!token.isEmpty() && parsedDate == null) {
			token.clear();
		}
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Clear tokens that appear within the content token
	 */
	private static void clearTokensBeforeContent(ParserToken content, ParserToken... tokens) {
		for (ParserToken token : tokens) {
			if (token.getEnd() < content.getEnd()) {
				token.clear();
			}
		}
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Merge disjointed content tokens. For example:
	 * 
	 * [ADD] [CONTENT] [PRIORITY] [CONTENT] [DEADLINE]
	 * 
	 * The priority token should be considered part of the content, hence:
	 * 
	 * [ADD] [--------- CONTENT ----------] [DEADLINE]
	 */
	private static void updateContentEnd(ParserToken content, String[] arr, ParserToken... tokens) {
		for (int i = arr.length - 1; i >= 0; i--) {
			boolean isBetween = false;
			for (ParserToken token : tokens) {
				if (Common.betweenInclusive(i, token.getStart(), token.getEnd())) {
					isBetween = true;
					break;
				}
			}
			if (!isBetween) {
				content.setEnd(i);
				return;
			}
		}
	}

```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Returns the Priority object representing the priority level
	 * 
	 * @param priorityString The priority level as a string
	 * @return The corresponding priority level
	 */
	private static Priority determinePriority(String priorityString) {
		if (priorityString.contains(Priority.HIGH.toString().toLowerCase())) {
			return Priority.HIGH;
		} else if (priorityString.contains(Priority.MEDIUM.toString().toLowerCase())) {
			return Priority.MEDIUM;
		} else if (priorityString.contains(Priority.LOW.toString().toLowerCase())) {
			return Priority.LOW;
		}
		return Priority.NONE;
	}
	
```
###### src\app\parser\CommandParser.java
``` java
	/**
	 * Returns the Priority object representing the priority level
	 * 
	 * @param priorityString The priority level as a string
	 * @return The corresponding priority level
	 */
	private static Priority determineSearchPriority(String priorityString) {
		if (priorityString.contains(Priority.HIGH.toString().toLowerCase())) {
			return Priority.HIGH;
		} else if (priorityString.contains(Priority.MEDIUM.toString().toLowerCase())) {
			return Priority.MEDIUM;
		} else if (priorityString.contains(Priority.LOW.toString().toLowerCase())) {
			return Priority.LOW;
		} else if (priorityString.contains(Priority.NONE.toString().toLowerCase())) {
			return Priority.NONE;
		}
		return null;
	}

```
###### src\app\parser\DateParser.java
``` java
public class DateParser {
	private static final List<String> DATE_PATTERNS = Common.getUnmodifiableList("dd/MM/yy", "d/MM/yy", "dd/M/yy", "d/M/yy",
			"dd/MM/yyyy", "d/MM/yyyy", "dd/M/yyyy", "d/M/yyyy", "dd-MM-yy", "d-MM-yy", "dd-M-yy", "d-M-yy",
			"dd-MM-yyyy", "d-MM-yyyy", "dd-M-yyyy", "d-M-yyyy");
	private static final List<String> TIME_PATTERNS = Common.getUnmodifiableList("h:mma", "hh:mma", "HHmm", "Hmm", "HHmm'hrs'",
			"Hmm'hrs'", "ha", "hha");
	private static final List<String> DAY_PATTERNS = Common.getUnmodifiableList("EEEE", "EEE");
	private static final List<String> TOMORROW_PATTERNS = Common.getUnmodifiableList("tomorrow", "tmr");
	
	/**
	 * Tries to return a LocalDateTime object from a given string representing a
	 * start date.
	 * 
	 * @param dateString The string representation of the date
	 * @return LocalDateTime if date can be parsed, else null
	 */
	public static LocalDateTime determineStartDate(String dateString) {
		return determineDate(dateString, null, false);
	}

	/**
	 * Tries to return a LocalDateTime object from a given string representing
	 * an end date.
	 * 
	 * @param dateString The string representation of the date
	 * @param reference The reference used if dateString contains only time
	 * @return LocalDateTime if date can be parsed, else null
	 */
	public static LocalDateTime determineEndDate(String dateString, LocalDateTime reference) {
		return determineDate(dateString, reference, true);
	}
	
	/**
	 * Converts a Date object to LocalDateTime object
	 * 
	 * @param date The Date object to convert
	 * @return The equivalent LocalDateTime object
	 */
	public static LocalDateTime toLocalDateTime(Date date) {
		LocalDateTime dateTime = LocalDateTime.ofInstant(date.toInstant(), ZoneOffset.systemDefault());
		return dateTime;
	}

	/**
	 * Tries to return a LocalDateTime object from a given string
	 * representation. A reference date is specified. For instance, "3pm" would
	 * result in a date equal to the reference date but with a time of "3pm".
	 * 
	 * @param dateString The string representation of the date
	 * @param reference The reference used if dateString contains only time
	 * @param isEndDate Determines the default time used if dateString contains
	 *            only date
	 * @return LocalDateTime object if date can be parsed, else null
	 */
	private static LocalDateTime determineDate(String dateString, LocalDateTime reference, boolean isEndDate) {
		dateString = dateString.toLowerCase();
		LocalDateTime date = null;

		// default time is 0000 if startDate, 2359 if endDate
		LocalTime defaultTime = LocalTime.of(0, 0);
		if (isEndDate) {
			defaultTime = LocalTime.of(23, 59);
		}

		// Special cases: "now", "today", "tomorrow"
		if (dateString.equalsIgnoreCase("now")) {
			date = LocalDateTime.now();
			return processDate(date);
		} else if (dateString.equalsIgnoreCase("today")) {
			date = LocalDateTime.now();
			date = setDefaultTime(date, defaultTime);
			return processDate(date);
		} else if (TOMORROW_PATTERNS.contains(dateString)) {
			date = LocalDateTime.now().plusDays(1);
			date = setDefaultTime(date, defaultTime);
			return processDate(date);
		}

		// check date patterns only
		for (String datePattern : DATE_PATTERNS) {
			date = getDateFromPattern(dateString, datePattern);
			if (date != null) {
				date = setDefaultTime(date, defaultTime);
				return processDate(date);
			}
			// check date + time patterns
			for (String timePattern : TIME_PATTERNS) {
				date = getDateFromPattern(dateString, datePattern + " " + timePattern);
				if (date != null) {
					return processDate(date);
				}
			}
		}

		// check time patterns only
		for (String timePattern : TIME_PATTERNS) {
			date = getDateFromPattern(dateString, timePattern);

			int dayOffset = 0;
			boolean skipReference = false;

			// check "today" + time pattern
			if (date == null) {
				date = getDateFromPattern(dateString, "'today' " + timePattern);
				if (date != null) {
					skipReference = true;
				}
			}

			// check "tomorrow" + time pattern
			if (date == null) {
				for (String tomorrowPattern : TOMORROW_PATTERNS) {
					String pattern = String.format("'%s' %s", tomorrowPattern, timePattern);
					date = getDateFromPattern(dateString, pattern);
					if (date != null) {
						skipReference = true;
						dayOffset = 1;
						break;
					}
				}
			}

			if (date != null) {
				if (!skipReference && reference != null) {
					LocalDateTime newDate = reference.withHour(date.getHour());
					newDate = newDate.withMinute(date.getMinute());
					return processDate(newDate);
				} else {
					LocalDateTime todayDate = LocalDateTime.now();
					todayDate = todayDate.plusDays(dayOffset).withHour(date.getHour()).withMinute(date.getMinute());
					return processDate(todayDate);
				}
			}

			// check day + time patterns
			for (String dayPattern : DAY_PATTERNS) {
				date = getDateFromPattern(dateString, dayPattern + " " + timePattern);
				if (date != null) {
					date = buildDateWithNextDay(date.getDayOfWeek().getValue(), date.getHour(), date.getMinute());
					return processDate(date);
				}
			}
		}

		// check day pattern only
		for (String dayPattern : DAY_PATTERNS) {
			date = getDateFromPattern(dateString, dayPattern);
			if (date != null) {
				date = buildDateWithNextDay(date.getDayOfWeek().getValue(), date.getHour(), date.getMinute());
				date = setDefaultTime(date, defaultTime);
				return processDate(date);
			}
		}
		return null;
	}

	/**
	 * Sets date with the default time specified.
	 * @param date The date to modify
	 * @param defaultTime The default time to use
	 * @return The date with the default time applied
	 */
	private static LocalDateTime setDefaultTime(LocalDateTime date, LocalTime defaultTime) {
		if (date != null && defaultTime != null) {
			return date.withHour(defaultTime.getHour()).withMinute(defaultTime.getMinute());
		}
		return null;
	}

	/**
	 * Strips seconds and nanoseconds from the date (set to zero).
	 * @param date The date to strip seconds/nanoseconds from
	 * @return The date without seconds/nanoseconds
	 */
	private static LocalDateTime processDate(LocalDateTime date) {
		if (date != null) {
			return date.withSecond(0).withNano(0);
		}
		return null;
	}

	/**
	 * Builds a Date object with the day set to the nearest day specified by the
	 * 'day' parameter. The hours and minutes of the Date object are also set as
	 * specified.
	 * 
	 * For example, if 'day' is 2, the returned date is the first Tuesday from
	 * now.
	 * 
	 * @param day An integer indicating the day: 1 -> monday, 2 -> tuesday, ...,
	 *            7 -> sunday
	 * @param hours The hours to set the date to
	 * @param minutes The minutes to set the date to
	 * @return The constructed date with the day, hours, and minutes set.
	 */
	private static LocalDateTime buildDateWithNextDay(int day, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.now();
		int diff = (day - date.getDayOfWeek().getValue());
		if (diff < 0) {
			diff += 7;
		}
		date = date.plusDays(diff).withHour(hours).withMinute(minutes);
		return date;
	}

	/**
	 * Tries to parse a string representation of a date using the given pattern.
	 * 
	 * @param dateString The string representation of the date
	 * @param pattern The pattern to try parsing with
	 * @return LocalDateTime object if date can be parsed, else null
	 */
	private static LocalDateTime getDateFromPattern(String dateString, String pattern) {
		// Use SimpleDateFormat because it's much more flexible for datetimes
		SimpleDateFormat sdf = new SimpleDateFormat(pattern);
		try {
			Date date = sdf.parse(dateString);
			String dateTimeFormat = sdf.format(date);
			if (dateTimeFormat.equalsIgnoreCase(dateString)) {
				return toLocalDateTime(date);
			}
		} catch (ParseException e) {
			// cannot be parsed
		}

		return null;
	}
}
```
###### src\app\storage\TaskStorage.java
``` java
	/**
	 * @return	TaskStorage instance.
	 */
	public static TaskStorage getInstance() {
		if (taskStorage == null) {
			taskStorage = new TaskStorage();
		}

		return taskStorage;
	}

```
###### src\app\util\Common.java
``` java
	/**
	 * Builds a string from a string array using specified start/end indexes.
	 * The start and end indexes are both inclusive.
	 * 
	 * @param start The start index
	 * @param end The end index
	 * @param array The array of strings
	 * @return The constructed string
	 */
	public static String getStringFromArrayIndexRange(int start, int end, String[] array) {
		String result = "";
		for (int i = start; i < array.length && i >= 0 && i <= end; i++) {
			result += array[i] + " ";
		}
		return result.trim();
	}

```
###### src\app\util\Common.java
``` java
	/**
	 * Builds a read-only list from the given arguments.
	 * 
	 * @param args Elements used to create the list
	 * @return A read-only list with the specified elements
	 */
	public static List<String> getUnmodifiableList(String... args) {
		return Collections.unmodifiableList(Arrays.asList(args));
	}

```
###### src\app\util\Common.java
``` java
	/**
	 * Compares the subject with a given range and returns true if subject is
	 * between or equal to lower and upper indexes.
	 * 
	 * @param subject The subject of the comparison
	 * @param lower The lower index
	 * @param upper The upper index
	 * @return True if subject is between or equal to lower and upper
	 */
	public static boolean betweenInclusive(int subject, int lower, int upper) {
		boolean result = (subject >= lower && subject <= upper);
		return result;
	}

	/**
	 * Returns the first whitespace delimited word of the specified string.
	 * 
	 * @param words The string to get the first word from
	 * @return The first word of the specified string
	 */
	public static String getFirstWord(String words) {
		return words.trim().split("\\s+")[0];
	}

	/**
	 * Removes the first whitespace delimited word of the specified string.
	 * 
	 * @param commandString The string to remove the first word from
	 * @return The resultant string without the first word
	 */
	public static String removeFirstWord(String commandString) {
		String word = Pattern.quote(getFirstWord(commandString));
		return commandString.replaceFirst(word, "").trim();
	}

```
###### src\app\util\Common.java
``` java
	public static List<String> getAliasesForCommandType(CommandType type) {
		switch (type) {
		case ADD:
			return CommandConstants.ALIASES_ADD;
		case DELETE:
			return CommandConstants.ALIASES_DELETE;
		case HELP:
			return CommandConstants.ALIASES_HELP;
		case THEME:
			return CommandConstants.ALIASES_THEME;
		case EXIT:
			return CommandConstants.ALIASES_EXIT;
		case MARK:
			return CommandConstants.ALIASES_MARK;
		case DISPLAY:
			return CommandConstants.ALIASES_DISPLAY;
		case EDIT:
			return CommandConstants.ALIASES_EDIT;
		case SEARCH:
			return CommandConstants.ALIASES_SEARCH;
		case SAVE:
			return CommandConstants.ALIASES_SAVE;
		case UNDO:
			return CommandConstants.ALIASES_UNDO;
		default:
			return new ArrayList<String>();
		}
	}
}
```
###### src\app\view\css\base.css
``` css

.commandInput {
	-fx-background-radius: 0.0;
}

/* Default background color for items */
.list-cell {
	-fx-background-color: #FCFCFC;
	-fx-padding: 0.0px;
}

.list-view {
	-fx-border-width: 0.0px 0.0 1.0px 0.0px;
	-fx-padding: 0px;
}

.textViewTextArea {
	-fx-background-radius: 0.0;
}

.textViewTextArea .content {
	-fx-background-radius: 0.0;
}

.header {
	-fx-font-family: "Segoe UI Semibold";
	-fx-font-size: 16px;
	-fx-border-width: 0 0 2px 0;
}

/* Individual task items. */
.taskItem {
	-fx-border-width: 0.0 0.0 1.0px 3px;
}

.taskItemTime, .taskItemDate {
	-fx-padding: 2px;
	-fx-background-radius: 3px;
	-fx-font-family: "Segoe UI";
	-fx-font-size: 12px;
}

.taskItem.taskDateLabel {
	-fx-font-size: 16px;
	-fx-padding: 2px 10px 2px 10px;
}

/* Begin completed tasks */
.taskItem.completed {
	-fx-opacity: 0.7;
}

.taskItem.completed .taskName .text {
	-fx-strikethrough: true;
}
/* End completed tasks */

/* Begin priority indicators */
.taskItem.priorityHigh .taskItemLine1, .taskItem.priorityHigh .taskItemLine2 {
	-fx-stroke: #F44336;
}

.taskItem.priorityMedium .taskItemLine1, .taskItem.priorityMedium .taskItemLine2 {
	-fx-stroke: #FFC107;
}

.taskItem.priorityLow .taskItemLine1, .taskItem.priorityLow .taskItemLine2 {
	-fx-stroke: #4CAF50;
}

.taskItem.priorityHigh .priorityImage {
	-fx-image: url("../images/priority_high_icon.png");
}

.taskItem.priorityMedium .priorityImage {
	-fx-image: url("../images/priority_medium_icon.png");
}

.taskItem.priorityLow .priorityImage {
	-fx-image: url("../images/priority_low_icon.png");
}
/* End priority indicators */

.commandInput {
	-fx-background-radius: 0.0;
}

.infoView {
	-fx-background-color: linear-gradient(from 0.0px 0.0px to 0.0px 6.0px, #DDDDDD, #FCFCFC);
}

.infoView .infoContent, .infoView .infoDate, .infoView .infoPriority, 
.infoView .infoDescription, .infoView .infoCommand, 
.infoView .infoRequired, .infoView .infoOptional {
	-fx-font-family: "Segoe UI Semibold";
}
```
###### src\app\view\css\theme_dark.css
``` css

.list-view {
	-fx-background-color: #323A43;
	-fx-border-color: #101010 transparent #101010 transparent;
}

.list-cell {
	-fx-background-color: #323A43;
}

.list-cell .label {
	-fx-text-fill: #FDFDFD; 
}

.header {
	-fx-background-color: #292E39;
	-fx-text-fill: #FDFDFD;
	-fx-border-color: transparent transparent #151515 transparent;
}

.taskItem.completed {
	-fx-background-color: #314937;
}

.taskItem.completed .taskItemDate, .taskItem.completed .taskItemTime {
	-fx-background-color: #9599a2;
}

/* Begin task items. */
.taskItem {
	-fx-background-color: #323A43;
}

.taskItem {
	-fx-border-color: transparent transparent #151515 transparent;
}

.taskItem.purple {
	-fx-border-color: transparent transparent #151515 #35294F;
}

.taskItem.taskDateLabel.purple {
	-fx-background-color: #35294F;
}

.taskItem.blue {
	-fx-border-color: transparent transparent #151515 #233E4B;
}

.taskItem.taskDateLabel.blue {
	-fx-background-color: #233E4B;
}

.taskItem.green {
	-fx-border-color: transparent transparent #151515 #234B39;
}

.taskItem.taskDateLabel.green {
	-fx-background-color: #234B39;
}

.taskItem.yellow {
	-fx-border-color: transparent transparent #151515 #503E25;
}

.taskItem.taskDateLabel.yellow {
	-fx-background-color: #503E25;
}

.taskItem.orange {
	-fx-border-color: transparent transparent #151515 #502B25;
}

.taskItem.taskDateLabel.orange {
	-fx-background-color: #502B25;
}

.taskItem.red {
	-fx-border-color: transparent transparent #151515 #371010;
}

.taskItem.taskDateLabel.red {
	-fx-background-color: #371010;
}

.taskItem.pink {
	-fx-border-color: transparent transparent #151515 #43223f;
}

.taskItem.taskDateLabel.pink {
	-fx-background-color: #43223f;
}
/* End task items. */

.taskItemTime, .taskItemDate {
	-fx-text-fill: #fcfcfc;
}

.taskItemTime {
	-fx-background-color: #386ee1;
}

.taskItemDate {
	-fx-background-color: #6b42e0;
}

.list-view .listViewTitle, .list-view .listViewNoTasks, .list-view .listViewInfo1, .list-view .listViewInfo2 {
	-fx-text-fill: #FDFDFD; 
}

.statusBar {
	-fx-background-color: #292E39;
}

.commandInput {
	-fx-background-color: #1C1F26;
	-fx-text-fill: #FDFDFD;
}

.textViewTextArea {
	-fx-background-color: #323A43;
	-fx-text-fill: #FDFDFD;
}

.textViewTextArea .content {
	-fx-background-color: #323A43;
}

.taskItemLines .taskItemLine1, .taskItemLines .taskItemLine2 {
	-fx-stroke: #151515;	
}

/* Status bar */
.statusBar.success {
	-fx-text-fill: #78CA5C;
}

.statusBar.error {
	-fx-text-fill: #F64641;
}

.statusBar.info {
	-fx-text-fill: #FDFDFD;
}
/* End status bar */

.infoView {
	-fx-background-color: linear-gradient(from 0.0px 0.0px to 0.0px 5.0px, #14181D, #292E39);
}

.infoView .text {
	-fx-fill: #FDFDFD;
}

.infoView .infoDate, .infoView .infoPriority {
	-fx-fill: #008ED6;
}

.infoView .infoCommand {
	-fx-fill: #EA7640;
}

.infoView .infoRequired {
	-fx-fill: #008ED6;
}

.infoView .infoOptional {
	-fx-fill: #A4A4A4;
}
```
###### src\app\view\css\theme_light.css
``` css

.list-view {
	-fx-background-color: #FCFCFC;
	-fx-border-color: transparent transparent #CCCCCC transparent;
}

.list-cell {
	-fx-background-color: #FCFCFC;
}

.header {
	-fx-border-color: transparent transparent #606060 transparent;
}

.taskItem.completed {
	-fx-background-color: #def5df;
}

.taskItem.completed .taskItemDate, .taskItem.completed .taskItemTime {
	-fx-background-color: #a3a7b1;
}

/* Begin task items. */
.taskItem {
	-fx-background-color: #FCFCFC;
}

.taskItem {
	-fx-border-color: transparent transparent #CCCCCC transparent;
}

.taskItem.purple {
	-fx-border-color: transparent transparent #CCCCCC #c4c4e1;
}

.taskItem.taskDateLabel.purple {
	-fx-background-color: #c4c4e1;
	-fx-border-color: transparent transparent #9292de #c4c4e1;
}

.taskItem.blue {
	-fx-border-color: transparent transparent #CCCCCC #bacee5;
}

.taskItem.taskDateLabel.blue {
	-fx-background-color: #bacee5;
	-fx-border-color: transparent transparent #7faee3 #bacee5;
}

.taskItem.green {
	-fx-border-color: transparent transparent #CCCCCC #afdab6;
}

.taskItem.taskDateLabel.green {
	-fx-background-color: #afdab6;
	-fx-border-color: transparent transparent #73d884 #afdab6;
}

.taskItem.yellow {
	-fx-border-color: transparent transparent #CCCCCC #f4e9c0;
}

.taskItem.taskDateLabel.yellow {
	-fx-background-color: #f4e9c0;
	-fx-border-color: transparent transparent #f2da80 #f4e9c0;
}

.taskItem.orange {
	-fx-border-color: transparent transparent #CCCCCC #f4dcb9;
}

.taskItem.taskDateLabel.orange {
	-fx-background-color: #f4dcb9;
	-fx-border-color: transparent transparent #f0c17e #f4dcb9;
}

.taskItem.red {
	-fx-border-color: transparent transparent #CCCCCC #dfa9ac;
}

.taskItem.taskDateLabel.red {
	-fx-background-color: #dfa9ac;
	-fx-border-color: transparent transparent #df7c82 #dfa9ac;
}

.taskItem.pink {
	-fx-border-color: transparent transparent #CCCCCC #edcedb;
}

.taskItem.taskDateLabel.pink {
	-fx-background-color: #edcedb;
	-fx-border-color: transparent transparent #ec8bb5 #edcedb;
}

/* End task items. */

.taskItemLines .taskItemLine1, .taskItemLines .taskItemLine2 {
	-fx-stroke: #CCCCCC;	
}

.taskItemTime, .taskItemDate {
	-fx-text-fill: #fcfcfc;
}

.taskItemTime {
	-fx-background-color: #4b7adf;
}

.taskItemDate {
	-fx-background-color: #7854df;
}

/* Status bar */
.statusBar.success {
	-fx-text-fill: green;
}

.statusBar.error {
	-fx-text-fill: red;
}

.statusBar.info {
	-fx-text-fill: black;
}
/* End status bar */

.infoView .infoDate, .infoView .infoPriority {
	-fx-fill: #0056BD;
}

.infoView .infoDescription, .infoView .infoContent {
	-fx-fill: #232323;
}

.infoView .infoCommand {
	-fx-fill: #E35B2C;
}

.infoView .infoRequired {
	-fx-fill: #0056BD;
}

.infoView .infoOptional {
	-fx-fill: #666666;
}
```
###### src\app\view\InfoViewManager.java
``` java
public class InfoViewManager {

	private static final String STYLE_INFOVIEW_DESCRIPTION = "infoDescription";
	private static final String STYLE_INFOVIEW_COMMAND = "infoCommand";
	private static final String STYLE_INFOVIEW_REQUIRED = "infoRequired";
	private static final String STYLE_INFOVIEW_OPTIONAL = "infoOptional";
	private static final String STYLE_INFOVIEW_CONTENT = "infoContent";
	private static final String STYLE_INFOVIEW_DATE = "infoDate";
	private static final String STYLE_INFOVIEW_PRIORITY = "infoPriority";

	private ViewManager viewManager;
	private DateTimeFormatter dateFormatter;
	private CommandType currentCommandType;

	@FXML
	private VBox infoViewLayout;

	/**
	 * This method is implicitly called when loaded from the FXMLLoader. A
	 * listener is bound to the height property of the layout and updates the size
	 * of the window accordingly.
	 */
	@FXML
	public void initialize() {
		dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yy hh:mma");
		currentCommandType = CommandType.INVALID;

		infoViewLayout.heightProperty().addListener((ChangeListener<Number>) (observable, oldValue, newValue) -> {
			double difference = newValue.doubleValue() - oldValue.doubleValue();
			viewManager.getPrimaryStage().setHeight(viewManager.getPrimaryStage().getHeight() + difference);
		});
	}

	/**
	 * Updates the info view
	 * 
	 * @param cmd The command object to specify info for
	 */
	public void updateView(Command cmd) {
		CommandType type = cmd.getCommandType();
		// Don't refresh info view if input is a ^substring of an alias for the currently displayed
		// command type.
		if (type == CommandType.INVALID && !cmd.getCommandString().isEmpty()) {
			List<String> aliases = Common.getAliasesForCommandType(currentCommandType);
			for (String alias : aliases) {
				if (alias.startsWith(cmd.getCommandString())) {
					return;
				}
			}
		}
		
		clearView();
		currentCommandType = cmd.getCommandType();

		switch (cmd.getCommandType()) {
		case ADD:
			setHelpText(HelpConstants.HELP_ADD_OVERVIEW, HelpConstants.HELP_ADD_DESCRIPTION);
			setCommandLabels(cmd);
			break;
		case EDIT:
			setHelpText(HelpConstants.HELP_EDIT_OVERVIEW, HelpConstants.HELP_EDIT_DESCRIPTION);
			setCommandEditLabels(cmd);
			break;
		case SEARCH:
			setHelpText(HelpConstants.HELP_SEARCH_OVERVIEW, HelpConstants.HELP_SEARCH_DESCRIPTION);
			setCommandLabels(cmd);
			break;
		case DELETE:
			setHelpText(HelpConstants.HELP_DELETE_OVERVIEW, HelpConstants.HELP_DELETE_DESCRIPTION);
			break;
		case DISPLAY:
			setHelpText(HelpConstants.HELP_DISPLAY_OVERVIEW, HelpConstants.HELP_DISPLAY_DESCRIPTION);
			break;
		case MARK:
			setHelpText(HelpConstants.HELP_MARK_OVERVIEW, HelpConstants.HELP_MARK_DESCRIPTION);
			break;
		case THEME:
			setHelpText(HelpConstants.HELP_THEME_OVERVIEW, HelpConstants.HELP_THEME_DESCRIPTION);
			break;
		case EXIT:
			setHelpText(HelpConstants.HELP_EXIT_OVERVIEW, HelpConstants.HELP_EXIT_DESCRIPTION);
			break;
		case SAVE:
			setHelpText(HelpConstants.HELP_SAVE_OVERVIEW, HelpConstants.HELP_SAVE_DESCRIPTION);
			break;
		default:
			break;
		}

		setPaddingIfHasChildren();
	}

	/**
	 * Sets the help text in the info view.
	 * 
	 * @param overview The command overview
	 * @param description The command description
	 */
	private void setHelpText(String overview, String description) {
		setHelpOverview(overview);
		setHelpDescription(description);
	}

	/**
	 * Sets the command overview in the info view.
	 * 
	 * @param overview The command overview
	 */
	private void setHelpOverview(String overview) {
		String commandWord = Common.getFirstWord(overview);
		overview = Common.removeFirstWord(overview);

		String optionalParams = overview;
		String requiredParams = "";

		while (!optionalParams.startsWith("[") && !optionalParams.isEmpty()) {
			requiredParams += Common.getFirstWord(optionalParams) + " ";
			optionalParams = Common.removeFirstWord(optionalParams);
		}

		Text commandWordText = buildText(commandWord, STYLE_INFOVIEW_COMMAND);
		Text requiredParamsText = buildText(" " + requiredParams.trim(), STYLE_INFOVIEW_REQUIRED);
		Text optionalParamsText = buildText(" " + optionalParams.trim(), STYLE_INFOVIEW_OPTIONAL);
		ArrayList<Text> texts = new ArrayList<Text>();
		addTextsToList(texts, commandWordText, requiredParamsText, optionalParamsText);
		addInfoRow(texts);
	}

	/**
	 * Sets the command description in the info view.
	 * 
	 * @param description The command overview
	 */
	private void setHelpDescription(String description) {
		ArrayList<Text> texts = new ArrayList<Text>();
		texts.add(buildText(description, STYLE_INFOVIEW_DESCRIPTION));
		addInfoRow(texts);
	}

	/**
	 * Sets labels specific to the edit command.
	 * 
	 * @param cmd The edit command
	 */
	private void setCommandEditLabels(Command cmd) {
		CommandEdit editCmd = (CommandEdit) cmd;
		Integer id = editCmd.getDisplayId();
		if (id != null) {
			setEditText(id.toString());
		}
		setContentText(cmd.getContent());
		setDateAndPriorityTexts(cmd);
		addSeparator();
	}

	/**
	 * Sets labels for the specified command object. This method is command-agnostic.
	 * 
	 * @param cmd The command object
	 */
	private void setCommandLabels(Command cmd) {
		setContentText(cmd.getContent());
		setDateAndPriorityTexts(cmd);
		addSeparator();
	}
	
	/**
	 * Sets the edit text for the edit command.
	 * 
	 * @param id ID of the task to be edited.
	 */
	private void setEditText(String id) {
		ArrayList<Text> texts = new ArrayList<Text>();
		if (!id.isEmpty()) {
			Text editingTaskId = buildText("Editing task with ID: ");
			Text idText = buildText(id);
			addTextsToList(texts, editingTaskId, idText);
			addInfoRow(texts);
		}
	}

	/**
	 * Adds a separator between the command overview/description and the rest of the command labels.
	 */
	private void addSeparator() {
		Separator separator = new Separator();
		Insets padding = new Insets(5, 0, 2, 0);
		separator.setPadding(padding);
		if (infoViewLayout.getChildren().size() > 2) {
			infoViewLayout.getChildren().add(2, separator);
		}
	}

	/**
	 * Sets the content text for the command.
	 * 
	 * @param content The content of the command
	 */
	private void setContentText(String content) {
		ArrayList<Text> texts = new ArrayList<Text>();
		if (content != null && !content.isEmpty()) {
			Text startQuote = buildText("\"");
			Text endQuote = buildText("\"");
			Text contentString = buildText(content, STYLE_INFOVIEW_CONTENT);
			addTextsToList(texts, startQuote, contentString, endQuote);
			addInfoRow(texts);
		}
	}

	/**
	 * Sets the labels for parsed date and priority level of the specified command.
	 * 
	 * @param cmd The command to set date and priority labels for
	 */
	private void setDateAndPriorityTexts(Command cmd) {
		ArrayList<Text> texts = new ArrayList<Text>();

		// Add parsed dates
		if (cmd.getRemoveField().contains(RemovableField.DATE)) {
			Text withDate = buildText(" with date ");
			Text dateNone = buildText("NONE", STYLE_INFOVIEW_DATE);
			addTextsToList(texts, withDate, dateNone);
		} else if (cmd.getStartDate() == null && cmd.getEndDate() != null) {
			Text due = buildText(" due ");
			Text endDate = buildText(dateFormatter.format(cmd.getEndDate()), STYLE_INFOVIEW_DATE);
			addTextsToList(texts, due, endDate);
		} else if (cmd.getStartDate() != null && cmd.getEndDate() != null) {
			Text from = buildText(" from ");
			Text startDate = buildText(dateFormatter.format(cmd.getStartDate()), STYLE_INFOVIEW_DATE);
			Text to = buildText(" to ");
			Text endDate = buildText(dateFormatter.format(cmd.getEndDate()), STYLE_INFOVIEW_DATE);
			addTextsToList(texts, from, startDate, to, endDate);
		}

		// Add parsed priority
		if (cmd.getPriority() != null
				&& (cmd.getRemoveField().contains(RemovableField.PRIORITY) || cmd.getPriority() != Priority.NONE)) {
			Text withPriority = buildText(" with priority ");
			Text priorityLevel = buildText(cmd.getPriority().toString(), STYLE_INFOVIEW_PRIORITY);
			addTextsToList(texts, withPriority, priorityLevel);
		}

		if (!texts.isEmpty()) {
			addInfoRow(texts);
		}
	}

	/**
	 * Utility method to add a series of text objects to a list.
	 * 
	 * @param list The list to add to
	 * @param texts The texts
	 */
	private void addTextsToList(List<Text> list, Text... texts) {
		for (Text text : texts) {
			list.add(text);
		}
	}

	/**
	 * Clears the info view.
	 */
	public void clearView() {
		infoViewLayout.getChildren().clear();
	}

	/**
	 * Builds and adds a row in the info view.
	 * 
	 * @param list A list of Text objects to construct the row with
	 */
	private void addInfoRow(List<Text> list) {
		TextFlow textFlow = new TextFlow();
		Insets padding = new Insets(0, 5, 0, 5);
		textFlow.setPrefWidth(300);
		textFlow.setPadding(padding);
		for (Text text : list) {
			textFlow.getChildren().add(text);
		}
		infoViewLayout.getChildren().add(textFlow);
	}

	/**
	 * Builds a Text object from a String object.
	 * @param content The content of the text object
	 * @return A Text object
	 */
	private Text buildText(String content) {
		return buildText(content, null);
	}

	/**
	 * Builds a Text object from a String object. A style class can be specified.
	 * @param content The content of the text object
	 * @return A Text object
	 */
	private Text buildText(String content, String styleClass) {
		Text text = new Text(content);
		text.getStyleClass().add("text");
		if (styleClass != null) {
			text.getStyleClass().add(styleClass);
		}
		return text;
	}

	/**
	 * Sets the padding of the info view if not empty.
	 */
	private void setPaddingIfHasChildren() {
		Insets padding = new Insets(0);
		if (!infoViewLayout.getChildren().isEmpty()) {
			padding = new Insets(5);
		}
		infoViewLayout.setPadding(padding);
	}

	public CommandType getCurrentCommandType() {
		return currentCommandType;
	}

	public void setViewManager(ViewManager viewManager) {
		this.viewManager = viewManager;
	}
}
```
###### src\app\view\InputViewManager.java
``` java
public class InputViewManager {

	private ViewManager viewManager;

	@FXML
	private TextField commandInput;

	/**
	 * This method is implicitly called when loaded from the FXMLLoader. A
	 * listener is bound to the text property of the input field and executed
	 * whenever the property changes.
	 */
	@FXML
	public void initialize() {
		commandInput.textProperty().addListener(change -> updateInfoView());
		
		commandInput.setOnKeyPressed(event -> {
			KeyCombination scrollUp = new KeyCodeCombination(KeyCode.UP, KeyCombination.CONTROL_DOWN);
			KeyCombination scrollDown = new KeyCodeCombination(KeyCode.DOWN, KeyCombination.CONTROL_DOWN);
			if (scrollUp.match(event)) {
				viewManager.scrollTaskList(ScrollDirection.UP);
			} else if (scrollDown.match(event)) {
				viewManager.scrollTaskList(ScrollDirection.DOWN);
			} else if (event.getCode() == KeyCode.UP) {
				prevCommandFromHistory();
			} else if (event.getCode() == KeyCode.DOWN) {
				nextCommandFromHistory();
			} else if (event.getCode() == KeyCode.SPACE) {
				completeCommand();
			}
		});
	}
	
	private void completeCommand() {
		String text = commandInput.getText();
		if (Common.getFirstWord(text).equals(text.trim())) {
			CommandType type = viewManager.getInfoViewCurrentCommandType();
			List<String> aliases = Common.getAliasesForCommandType(type);
			if (!aliases.isEmpty() && !aliases.contains(text)) {
				setText(text.replaceFirst(Common.getFirstWord(text), aliases.get(0) + " "), true);
				positionCaretAtEnd();
			}
		}
	}
	
	private void nextCommandFromHistory() {
		String text = CommandController.getInstance().getCommandHistory().next();
		setText(text, true);
		positionCaretAtEnd();
	}
	
	private void prevCommandFromHistory() {
		String text = CommandController.getInstance().getCommandHistory().prev();
		setText(text, false);
		positionCaretAtEnd();
	}
	
	private void setText(String text, boolean allowEmpty) {
		if (allowEmpty || !text.isEmpty()) {
			Platform.runLater(() -> {
				commandInput.setText(text);
			});
		}		
	}
	
	private void positionCaretAtEnd() {
		Platform.runLater(() -> {
			commandInput.positionCaret(commandInput.getLength());
		});
	}

	/**
	 * Updates the view showing information about the current input
	 */
	private void updateInfoView() {
		String commandString = commandInput.getText();
		Command cmd = CommandController.getInstance().createCommand(commandString);
		if (cmd != null) {
			viewManager.updateInfoView(cmd);
		}
	}

	/**
	 * This method will be executed when the user presses the ENTER key on the
	 * command input field.
	 */
	public void onKeypressEnter() {
		String input = commandInput.getText();
		LogHelper.getInstance().getLogger().info("User pressed enter key with input: " + input);
		executeUserInput(input);
	}
	
	public void executeUserInput(String input) {
		ViewState newViewState = CommandController.getInstance().executeCommand(input);
		viewManager.updateView(newViewState);
		commandInput.clear();
	}

	/**
	 * This sets a reference to the ViewManager that initialized this class.
	 * 
	 * @param viewManager The ViewManager that initialized this class.
	 */
	public void setViewManager(ViewManager viewManager) {
		this.viewManager = viewManager;
	}
}
```
###### src\app\view\TaskListItemViewManager.java
``` java
public class TaskListItemViewManager extends ListCell<TaskCell> {

	private Task task;
	private int index;
	private String style;

	@FXML
	private AnchorPane taskListItemViewLayout;
	@FXML
	private Label taskId;
	@FXML
	private Label taskName;
	@FXML
	private Tooltip taskNameTooltip;
	@FXML
	private ImageView priorityImage;
	@FXML
	private VBox taskItemDateVbox;

	/**
	 * This method is implicitly called whenever a item (TaskListItemView) is
	 * added to the ListView (TaskListView).
	 * 
	 * The components of the item is updated with the supplied Task parameter.
	 */
	@Override
	public void updateItem(TaskCell taskCell, boolean empty) {
		super.updateItem(taskCell, empty);
		// Always clear the content due to a JavaFX quirk with updating cells.
		clearContent();
		if (!empty && taskCell != null) {
			style = taskCell.getStyle();
			if (taskCell.getTask() != null) {
				task = taskCell.getTask();
				index = taskCell.getIndex();
				setGraphic(taskListItemViewLayout);
				setStyle();
				setLabels();
				setPriority();
			} else {
				Label label = buildDateHeader(taskCell.getLabel());
				setGraphic(label);
			}
		}
	}

	private void setStyle() {
		taskListItemViewLayout.getStyleClass().add(style);
	}

	private Label buildDateHeader(String labelText) {
		Label label = new Label(labelText);
		label.setMaxWidth(Double.MAX_VALUE);
		label.getStyleClass().addAll("taskItem", "taskDateLabel", style);
		return label;
	}

	/**
	 * Resets all cell content.
	 */
	private void clearContent() {
		setGraphic(null);
		taskItemDateVbox.getChildren().clear();
		priorityImage.setVisible(false);
		clearStyleClasses();
	}

	private void clearStyleClasses() {
		taskListItemViewLayout.getStyleClass().clear();
		taskListItemViewLayout.getStyleClass().add("taskItem");
	}

	/**
	 * Sets the item labels using the supplied Task.
	 */
	private void setLabels() {
		setIndex();
		setContent();
		setDates();
		setCompleted();
	}

	/**
	 * Sets strike-through effect for completed task
	 */
	private void setCompleted() {
		if (this.task.isCompleted()) {
			taskListItemViewLayout.getStyleClass().add("completed");
		} else if (!this.task.isCompleted()) {
			taskListItemViewLayout.getStyleClass().remove("completed");
		}
	}

	/**
	 * Sets the 1-index of this task cell.
	 */
	private void setIndex() {
		taskId.setText(String.valueOf(index));
	}

	/**
	 * Sets the main content of this task cell as well as its tooltip.
	 */
	private void setContent() {
		taskName.setText(task.getName());
		taskNameTooltip.setText(task.getName());
	}

	/**
	 * Sets the dates of this task cell.
	 */
	public void setDates() {
		// Duration
		if (task.getStartDate() != null && task.getEndDate() != null) {
			Label startTime = buildTimeLabel(task.getStartDate());
			Label to = new Label("to");
			Label endTime = buildTimeLabel(task.getEndDate());
			Label endDate = null;

			// if endDate is on another day, display the endDate in addition to
			// the default startTime and endTime
			if (!task.getEndDate().toLocalDate().equals(task.getStartDate().toLocalDate())) {
				endDate = buildDateLabel(task.getEndDate());
				addDateRow(startTime);
				addDateRow(to, endDate, endTime);
			} else {
				addDateRow(startTime, to, endTime);
			}

			// Deadline
		} else if (task.getEndDate() != null) {
			Label to = new Label("by");
			Label endTime = buildTimeLabel(task.getEndDate());
			addDateRow(to, endTime);
		}
	}

	/**
	 * Adds a row to the date section of the task item
	 * 
	 * @param labels The labels the row should contain
	 */
	private void addDateRow(Label... labels) {
		HBox row = new HBox();
		row.setAlignment(Pos.CENTER_RIGHT);
		row.setSpacing(4);
		for (Label label : labels) {
			if (label != null) {
				row.getChildren().add(label);
			}
		}
		taskItemDateVbox.getChildren().add(row);
	}

	/**
	 * Builds the label representing the date
	 * 
	 * @param dateTime LocalDateTime to get the date from
	 * @return The built label
	 */
	private Label buildDateLabel(LocalDateTime dateTime) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yy");
		Label label = new Label(dateTime.toLocalDate().format(formatter));
		label.setAlignment(Pos.CENTER_RIGHT);
		label.getStyleClass().add("taskItemDate");
		return label;
	}

	/**
	 * Builds the label representing the time
	 * 
	 * @param dateTime LocalDateTime to get the time from
	 * @return The built label
	 */
	private Label buildTimeLabel(LocalDateTime dateTime) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern("hh:mma");
		Label label = new Label(dateTime.toLocalTime().format(formatter));
		label.setAlignment(Pos.CENTER_RIGHT);
		label.getStyleClass().add("taskItemTime");
		return label;
	}

	/**
	 * Sets the item to display the appropriate priority level, if applicable.
	 */
	private void setPriority() {
		if (task.getPriority() != null) {
			switch (task.getPriority()) {
			case HIGH:
				setPriorityImage("priorityHigh");
				return;
			case MEDIUM:
				setPriorityImage("priorityMedium");
				return;
			case LOW:
				setPriorityImage("priorityLow");
				return;
			case NONE: // Intentional fall-through and default case
			default:
				return;
			}
		}
	}

	/**
	 * Displays the priority image by setting the style class and making the
	 * image visible.
	 * 
	 * @param styleClass A style class of the form: .priority[High | Medium |
	 *            Low]
	 */
	private void setPriorityImage(String styleClass) {
		taskListItemViewLayout.getStyleClass().add(styleClass);
		priorityImage.setVisible(true);
	}

}
```
###### src\app\view\TaskListViewManager.java
``` java
public class TaskListViewManager {
	private ViewManager viewManager;

	@FXML
	private ListView<TaskCell> taskListViewLayout;

	/**
	 * This method is implicitly called when the TaskListView is loaded from the
	 * FXMLLoader. The logic for setting our custom cell (TaskListItemView) is
	 * defined by setting the cell factory of the TaskListView.
	 */
	@FXML
	public void initialize() {
		taskListViewLayout.setCellFactory(new Callback<ListView<TaskCell>, ListCell<TaskCell>>() {
			@Override
			public ListCell<TaskCell> call(ListView<TaskCell> listView) {
				try {
					FXMLLoader loader = new FXMLLoader();
					loader.setLocation(Main.class.getResource("view/fxml/TaskListItemView.fxml"));
					loader.load();
					return loader.getController();
				} catch (IOException e) {
					LogHelper.getInstance().getLogger().severe(e.getMessage());
				}
				return null;
			}
		});
	}
	
	public void scrollToTop() {
		Node node = taskListViewLayout.lookup(".scroll-bar");
		if (node instanceof ScrollBar) {
			ScrollBar scrollBar = (ScrollBar) node;
			scrollBar.setValue(0);
		}
	}

	public void scrollTo(Task task) {
		UUID uuid = task.getId();
		for (TaskCell cell : taskListViewLayout.getItems()) {
			if (cell.getTask() != null && cell.getTask().getId().equals(uuid)) {
				taskListViewLayout.scrollTo(cell);
				break;
			}
		}
	}

	/**
	 * Updates the list of tasks shown to the user
	 * 
	 * @param tasks A TaskList object containing the list of tasks.
	 */
	public void updateView(TaskList tasks) {
		taskListViewLayout.setItems(buildTaskCells(tasks));
		viewManager.setHeaderVisible(true);
	}

	private ObservableList<TaskCell> buildTaskCells(TaskList tasks) {
		// assume tasks is sorted already.
		ObservableList<TaskCell> taskCells = FXCollections.observableArrayList();
		Queue<String> colors = ViewConstants.getItemColorsQueue();

		LocalDate labelDate = null;
		String currentColor = "";
		int index = 1;

		for (Task task : tasks.getTaskList()) {
			LocalDate sortKey = null;
			if (task.getSortKey() != null) {
				sortKey = task.getSortKey().toLocalDate();
			}

			// If first occurrence of a new date, add a TaskCell for the date
			// label
			if ((sortKey != null && labelDate == null)
					|| (labelDate != null && sortKey != null && !labelDate.isEqual(sortKey))) {
				currentColor = colors.poll();
				colors.offer(currentColor);
				labelDate = task.getSortKey().toLocalDate();
				TaskCell cell = new TaskCell(labelDate, currentColor);
				taskCells.add(cell);
			}

			// Add a TaskCell for the Task item
			TaskCell cell = new TaskCell(task, index++, currentColor);
			taskCells.add(cell);
		}

		return taskCells;
	}

	public void scrollTaskList(ScrollDirection direction) {
		double step = 5.0 / taskListViewLayout.getItems().size();
		Node node = taskListViewLayout.lookup(".scroll-bar");
		if (node instanceof ScrollBar) {
			ScrollBar scrollBar = (ScrollBar) node;
			double newValue = scrollBar.getValue();

			if (direction == ScrollDirection.UP && scrollBar.getValue() != 0) {
				newValue = scrollBar.getValue() - step;
			} else if (direction == ScrollDirection.DOWN && scrollBar.getValue() != scrollBar.getMax()) {
				newValue = scrollBar.getValue() + step;
			}

			if (newValue < 0) {
				newValue = 0;
			} else if (newValue > scrollBar.getMax()) {
				newValue = scrollBar.getMax();
			}

			// Animate scroll to provide smooth scrolling
			Timeline timeline = new Timeline();
			KeyValue kv = new KeyValue(scrollBar.valueProperty(), newValue);
			KeyFrame kf = new KeyFrame(Duration.millis(200), kv);
			timeline.getKeyFrames().add(kf);
			timeline.play();
		}
	}

	/**
	 * This sets a reference to the ViewManager that initialized this class.
	 * 
	 * @param viewManager The ViewManager that initialized this class.
	 */
	public void setViewManager(ViewManager viewManager) {
		this.viewManager = viewManager;
	}
}
```
###### src\app\view\TextViewManager.java
``` java
public class TextViewManager {
	
	@FXML
	private TextArea textArea;
	
	public void setText(String text) {
		textArea.setText(text);
	}
}
```
###### src\app\view\ViewManager.java
``` java
public class ViewManager {

	private Stage primaryStage;

	private BorderPane rootLayout;
	private AnchorPane inputViewLayout;
	private AnchorPane textViewLayout;
	private VBox infoViewLayout;
	private VBox taskListViewLayout;

	private InputViewManager inputViewManager;
	private TaskListViewManager taskListViewManager;
	private TextViewManager textViewManager;
	private InfoViewManager infoViewManager;

	@FXML
	private Label header;
	@FXML
	private Label statusBar;

	/**
	 * This is the main initialization method for the ViewManager. This method
	 * initializes all relevant components, such as the CommandController and
	 * views.
	 * 
	 * @param primaryStage The main window.
	 */
	public void initialize(Stage primaryStage, BorderPane rootLayout) {
		this.primaryStage = primaryStage;
		this.rootLayout = rootLayout;
		initializeViews();
		updateView(CommandController.getInstance().getCurrentViewState());
		showStage(primaryStage);
	}

	/**
	 * Initializes all views for the program. Views initialized: TaskList,
	 * Input, Text, Info.
	 * 
	 * @param primaryStage The stage (window) for which the views will be
	 *            attached to.
	 */
	private void initializeViews() {
		initializeTaskListView();
		initializeInputView();
		initializeTextView();
		initializeInfoView();
	}

	/**
	 * Applies the root view to the stage (window) before displaying the stage.
	 * 
	 * @param primaryStage The stage (window) to display.
	 */
	public void showStage(Stage primaryStage) {
		Scene scene = new Scene(rootLayout);
		primaryStage.setScene(scene);
		primaryStage.show();
	}

	/**
	 * Initializes the TaskListView.
	 */
	private void initializeTaskListView() {
		LogHelper.getInstance().getLogger().info("Initializing tasklist view");
		try {
			FXMLLoader loader = buildFxmlLoader("view/fxml/TaskListView.fxml");
			taskListViewLayout = loader.load();
			taskListViewManager = loader.getController();
			taskListViewManager.setViewManager(this);
			showTaskList();
		} catch (IOException e) {
			LogHelper.getInstance().getLogger().severe(e.getMessage());
		}
	}

	/**
	 * Initializes the InputView, which contains a TextField to take input from
	 * the user.
	 */
	private void initializeInputView() {
		LogHelper.getInstance().getLogger().info("Initializing input view");
		try {
			FXMLLoader loader = buildFxmlLoader("view/fxml/InputView.fxml");
			inputViewLayout = loader.load();
			inputViewManager = loader.getController();
			inputViewManager.setViewManager(this);
			VBox vbox = (VBox) rootLayout.getBottom();
			vbox.getChildren().add(inputViewLayout);
		} catch (IOException e) {
			LogHelper.getInstance().getLogger().info(e.getMessage());
		}
	}

	/**
	 * Initializes the TextView, which is simply a text area to show information
	 * (such as help).
	 */
	private void initializeTextView() {
		LogHelper.getInstance().getLogger().info("Initializing text view");
		try {
			FXMLLoader loader = buildFxmlLoader("view/fxml/TextView.fxml");
			textViewLayout = loader.load();
			textViewManager = loader.getController();
		} catch (IOException e) {
			LogHelper.getInstance().getLogger().severe(e.getMessage());
		}
	}

	/**
	 * Initializes the InfoView, which contains information about the current
	 * user input.
	 */
	private void initializeInfoView() {
		LogHelper.getInstance().getLogger().info("Initializing text view");
		try {
			FXMLLoader loader = buildFxmlLoader("view/fxml/InfoView.fxml");
			infoViewLayout = loader.load();
			infoViewManager = loader.getController();
			infoViewManager.setViewManager(this);
			VBox vbox = (VBox) rootLayout.getBottom();
			vbox.getChildren().add(infoViewLayout);
		} catch (IOException e) {
			LogHelper.getInstance().getLogger().severe(e.getMessage());
		}
	}
	
	public void updateView(ViewState viewState) {
		if (viewState != null) {
			setHeader(viewState.getHeader());
			setStatus(viewState.getStatusMessage(), viewState.getStatusType());
			updateTaskList(viewState.getTaskList());
			updateTextView(viewState.getTextArea());
			setTheme(viewState.getTheme());
			showView(viewState.getActiveView());
			executeActions(viewState.getActions());
		}
	}
	
	private void showView(ViewType viewType) {
		if (viewType == ViewType.TASK_LIST) {
			showTaskList();
		} else if (viewType == ViewType.TEXT_VIEW) {
			showTextView();
		}
	}
	
	private void executeActions(List<Action> actions) {
		for (Action action : actions) {
			switch (action.getActionType()) {
			case SCROLL_TASK_LIST_TO:
				scrollTaskListTo(action.getActionObject());
				break;
			case SCROLL_TASK_LIST_TO_TOP:
				scrollTaskListToTop();
				break;
			case EXIT:	// exit the application
				Platform.exit();
				break;
			default:
				break;
			}
		}
	}

	/**
	 * Updates text of the task list header
	 * 
	 * @param text The text for the header to read
	 */
	public void setHeader(String text) {
		if (text != null) {
			header.setText(text);
		}
	}

	/**
	 * Sets the visibility of the header.
	 * 
	 * @param visible True to make header visible
	 */
	public void setHeaderVisible(boolean visible) {
		if (visible) {
			header.setPrefHeight(-1);
			header.setMinHeight(-1);
		} else {
			header.setPrefHeight(0);
			header.setMinHeight(0);
		}
	}

	public void scrollTaskListToTop() {
		taskListViewManager.scrollToTop();
	}

	/**
	 * Scrolls the task list to show the specified task.
	 * 
	 * @param task The task to scroll to
	 */
	public void scrollTaskListTo(Object object) {
		if (object instanceof Task) {
			taskListViewManager.scrollTo((Task) object);
		}
	}

	/**
	 * Updates and shows the task list to the user.
	 * 
	 * @param tasks TaskList containing a list of tasks.
	 */
	public void updateTaskList(TaskList tasks) {
		taskListViewManager.updateView(tasks);
	}

	/**
	 * Shows the task list to the user.
	 */
	public void showTaskList() {
		rootLayout.setCenter(taskListViewLayout);
	}

	/**
	 * Updates the shows the text view to the user.
	 * 
	 * @param text The text to populate the text view with.
	 */
	public void updateTextView(String text) {
		if (text != null) {
			textViewManager.setText(text);
		}
	}

	/**
	 * Shows the text area to the user.
	 */
	public void showTextView() {
		rootLayout.setCenter(textViewLayout);
	}

	/**
	 * Sets the status bar text with specified StatusType and corresponding
	 * color.
	 * 
	 * @param text The status bar text to set.
	 * @param type The StatusType of the text.
	 */
	public void setStatus(String text, StatusType type) {
		if (text != null && type != null) {
			statusBar.setText(text);
			statusBar.getStyleClass().removeAll(ViewConstants.STATUS_STYLE_SUCCESS, ViewConstants.STATUS_STYLE_ERROR,
					ViewConstants.STATUS_STYLE_INFO);
			statusBar.getStyleClass().add(determineStatusStyleClass(type));
		}
	}

	/**
	 * Sets the current theme of the program.
	 * 
	 * @param themeCss The new theme to use. This parameter is either
	 *            ViewConstants.THEME_LIGHT_CSS or ViewConstants.THEME_DARK_CSS.
	 */
	public void setTheme(String themeCss) {
		if (themeCss != null) {
			rootLayout.getStylesheets().removeAll(ViewConstants.THEME_LIGHT_CSS, ViewConstants.THEME_DARK_CSS);
			rootLayout.getStylesheets().add(themeCss);
		}
	}

	/**
	 * Updates the info view using parameters from the specified Command object
	 * parsed from the user's input
	 * 
	 * @param cmd The Command object parsed from user input
	 */
	public void updateInfoView(Command cmd) {
		infoViewManager.updateView(cmd);
	}
	
	public CommandType getInfoViewCurrentCommandType() {
		return infoViewManager.getCurrentCommandType();
	}

	public void scrollTaskList(ScrollDirection direction) {
		taskListViewManager.scrollTaskList(direction);
	}
	
	public void sendCommandToInput(String command) {
		inputViewManager.executeUserInput(command);
	}

	/**
	 * Determines the style class for the specified StatusType. This style class
	 * will be used by the theme CSS files to properly color the text.
	 * 
	 * @param type The StatusType of the text.
	 * @return The style class for the specified StatusType, as a string.
	 */
	private String determineStatusStyleClass(StatusType type) {
		switch (type) {
		case SUCCESS:
			return ViewConstants.STATUS_STYLE_SUCCESS;
		case ERROR:
			return ViewConstants.STATUS_STYLE_ERROR;
		case INFO:
		default:
			return ViewConstants.STATUS_STYLE_INFO;
		}
	}

	/**
	 * Builds and returns a FXMLLoader object from a given string path pointing
	 * to an .fxml file.
	 * 
	 * @param fxml The path to the .fxml file
	 * @return The constructed FXMLLoader
	 */
	private FXMLLoader buildFxmlLoader(String fxml) {
		FXMLLoader loader = new FXMLLoader();
		loader.setLocation(Main.class.getResource(fxml));
		return loader;
	}

	/**
	 * @return The primary stage (window)
	 */
	public Stage getPrimaryStage() {
		return primaryStage;
	}
}
```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseDueDate() {
		String input = "add buy milk due 15/11/15 0959";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedEndDate = buildDate(2015, 11, 15, 9, 59);
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertNull(cmd.getStartDate());
		assertEquals("buy milk", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseRangeOfDates() {
		String input = "add buy milk from 15/11/2015 to 21/11/2015";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDate(2015, 11, 15, 0, 0);
		LocalDateTime expectedEndDate = buildDate(2015, 11, 21, 0, 0);
		assertTrue(areDatesSame(cmd.getStartDate(), expectedStartDate));
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals("buy milk", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseStartDateOnlyTime() {
		// start date only has time
		String input = "add buy milk from 3pm to 25/11/2015 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDate(0, 15, 0);
		LocalDateTime expectedEndDate = buildDate(2015, 11, 25, 17, 0);
		assertTrue(areDatesSame(cmd.getStartDate(), expectedStartDate));
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals("buy milk", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseEndDateRelatedToStartDate() {
		// end date only has time, related to start date
		String input = "add buy milk from 15/12/2015 3pm to 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDate(2015, 12, 15, 15, 0);
		LocalDateTime expectedEndDate = buildDate(2015, 12, 15, 17, 0);
		assertTrue(areDatesSame(cmd.getStartDate(), expectedStartDate));
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals("buy milk", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseMultipleStartKeywords() {
		// multiple `from` keywords, but first `from` is part of content
		String input = "add buy milk from store from 3pm to 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDate(0, 15, 0);
		LocalDateTime expectedEndDate = buildDate(0, 17, 0);
		assertTrue(areDatesSame(cmd.getStartDate(), expectedStartDate));
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals("buy milk from store", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseStartDateActuallyContent() {
		/*
		 * Has a `from-to` sequence, but the 'start date' is actually part of
		 * the content.
		 */
		String input = "add buy milk from store due 25/12/15 9pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedEndDate = buildDate(2015, 12, 25, 21, 0);
		assertNull(cmd.getStartDate());
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals("buy milk from store", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseOnlyStartKeywordInContent() {
		// Has a `from` keyword but no corresponding `to` keyword
		String input = "add buy milk from store";
		Command cmd = CommandController.getInstance().createCommand(input);
		assertNull(cmd.getStartDate());
		assertNull(cmd.getEndDate());
		assertEquals("buy milk from store", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseContentEndingWithStartKeyword() {
		// Content ending with `from` keyword
		String input = "add buy milk from";
		Command cmd = CommandController.getInstance().createCommand(input);
		assertNull(cmd.getStartDate());
		assertNull(cmd.getEndDate());
		assertEquals("buy milk from", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseInvalidDateRange() {
		// from store to 5pm is invalid because 'store' is not a date,
		// hence up to 'store' is considered content.
		String input = "add buy milk from store to 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedEndDate = buildDate(0, 17, 0);
		assertNull(cmd.getStartDate());
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));
		assertEquals("buy milk from store", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseValidStartDateWithNoEndKeyword() {
		// Has a `from <date>` sequence without end date.
		String input = "add buy milk from 25/12/15";
		Command cmd = CommandController.getInstance().createCommand(input);
		assertNull(cmd.getStartDate());
		assertNull(cmd.getEndDate());
		assertEquals("buy milk from 25/12/15", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseEmptyContentWithKeywords() {
		// after parsing keywords, content will be empty ("").
		String input = "add priority high from 3pm to 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDate(0, 15, 0);
		LocalDateTime expectedEndDate = buildDate(0, 17, 0);
		assertTrue(areDatesSame(cmd.getStartDate(), expectedStartDate));
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals(Priority.HIGH, cmd.getPriority());
		assertEquals("", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParsePriority() {
		// high priority
		String input = "add buy milk priority high";
		Command cmd = CommandController.getInstance().createCommand(input);
		assertEquals(Priority.HIGH, cmd.getPriority());
		assertEquals("buy milk", cmd.getContent());

		// medium priority
		input = "add buy milk pri medium";
		cmd = CommandController.getInstance().createCommand(input);
		assertEquals(Priority.MEDIUM, cmd.getPriority());

		// low priority
		input = "add buy milk p low";
		cmd = CommandController.getInstance().createCommand(input);
		assertEquals(Priority.LOW, cmd.getPriority());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParsePriorityWithDueDate() {
		String input = "add buy milk priority high due 25/12/2015 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedEndDate = buildDate(2015, 12, 25, 17, 0);
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals(Priority.HIGH, cmd.getPriority());
		assertEquals("buy milk", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParsePriorityWithRangeOfDates() {
		String input = "add buy milk from store priority high start 21/12/15 6:30am due 25/12/2015 5pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDate(2015, 12, 21, 6, 30);
		LocalDateTime expectedEndDate = buildDate(2015, 12, 25, 17, 0);
		assertTrue(areDatesSame(cmd.getStartDate(), expectedStartDate));
		assertTrue(areDatesSame(cmd.getEndDate(), expectedEndDate));
		assertEquals(Priority.HIGH, cmd.getPriority());
		assertEquals("buy milk from store", cmd.getContent());
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseSupportedDateFormats() {
		String input = "add buy milk due 9/5/16";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedEndDate = buildDate(2016, 5, 9, 0, 0);
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));

		input = "add buy milk due 09/5/16";
		cmd = CommandController.getInstance().createCommand(input);
		expectedEndDate = buildDate(2016, 5, 9, 0, 0);
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));

		input = "add buy milk due 9/05/16";
		cmd = CommandController.getInstance().createCommand(input);
		expectedEndDate = buildDate(2016, 5, 9, 0, 0);
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));

		input = "add buy milk due 09/05/16";
		cmd = CommandController.getInstance().createCommand(input);
		expectedEndDate = buildDate(2016, 5, 9, 0, 0);
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));

		input = "add buy milk due 9/5/2016";
		cmd = CommandController.getInstance().createCommand(input);
		expectedEndDate = buildDate(2016, 5, 9, 0, 0);
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));

		input = "add buy milk due 9-5-16";
		cmd = CommandController.getInstance().createCommand(input);
		expectedEndDate = buildDate(2016, 5, 9, 0, 0);
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseRangeOfDaysWithTime() {
		String input = "add buy milk from monday 5:30pm to 14/5/2050";
		Command cmd = CommandController.getInstance().createCommand(input);
		LocalDateTime expectedStartDate = buildDateWithNextDay(1, 17, 30);
		LocalDateTime expectedEndDate = buildDate(2050, 5, 14, 0, 0);
		assertTrue(areDatesSame(expectedStartDate, cmd.getStartDate()));
		assertTrue(areDatesSame(expectedEndDate, cmd.getEndDate()));
	}

```
###### src\tests\CommandParserTest.java
``` java
	@Test
	public void testParseStartAfterEndDate() {
		String input = "add buy milk from 5pm to 3pm";
		Command cmd = CommandController.getInstance().createCommand(input);
		assertNull(cmd.getStartDate());
		assertNull(cmd.getEndDate());
		assertEquals("buy milk from 5pm to 3pm", cmd.getContent());
	}
	
```
###### src\tests\CommandParserTest.java
``` java
	private boolean areDatesSame(LocalDateTime date1, LocalDateTime date2) {
		int difference = date1.compareTo(date2);
		return (difference < 1000 || difference > -1000);
	}

```
###### src\tests\CommandParserTest.java
``` java
	private LocalDateTime buildDate(int daysOffsetFromNow, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.now();
		date = date.plusDays(daysOffsetFromNow).withHour(hours).withMinute(minutes).withSecond(0).withNano(0);
		return date;
	}

```
###### src\tests\CommandParserTest.java
``` java
	private LocalDateTime buildDate(int year, int month, int day, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.of(year, month, day, hours, minutes).withSecond(0).withNano(0);
		return date;
	}

```
###### src\tests\CommandParserTest.java
``` java
	// day: 0 -> sunday, 1 -> monday, ..., 6 -> saturday
	private LocalDateTime buildDateWithNextDay(int day, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.now();
		int diff = (day - date.getDayOfWeek().getValue());
		if (diff < 0) {
			diff += 7;
		}
		date = date.plusDays(diff).withHour(hours).withMinute(minutes).withSecond(0);
		return date;
	}

}
```
###### src\tests\DateParserTest.java
``` java
public class DateParserTest {

	@Test
	public void testToLocalDateTime() {
		// 15/6/2016 0900hrs
		long epochDate = System.currentTimeMillis();
		Date date = new Date(epochDate);
		LocalDateTime expected = LocalDateTime.ofInstant(Instant.ofEpochMilli(epochDate), ZoneOffset.systemDefault());
		assertEquals(expected, DateParser.toLocalDateTime(date));
	}

	@Test
	public void testDefaultTime() {
		String dateString = "today";
		
		LocalDateTime expected = buildDate(0, 0, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		expected = buildDate(0, 23, 59);
		date = DateParser.determineEndDate(dateString, null);
		assertEquals(expected, date);
	}
	
	@Test
	public void testDayOffset() {
		String dateString = "tomorrow";
		
		LocalDateTime expected = buildDate(1, 0, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testDatePatterns() {
		String dateString = "15/9/16";
		LocalDateTime expected = buildDate(2016, 9, 15, 0, 0);
		
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "15-9-16";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "15-9-2016";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "15-09-16";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testTimePatterns() {
		String dateString = "5pm";
		LocalDateTime expected = buildDate(0, 17, 0);
		
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "05pm";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "5:00pm";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "05:00pm";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "1700";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "1700hrs";
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testNextDay() {
		String dateString = "monday";
		LocalDateTime expected = buildDateWithNextDay(1, 0, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
		
		dateString = "friday";
		expected = buildDateWithNextDay(5, 0, 0);
		date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testReferenceDate() {
		String dateString = "5pm";
		LocalDateTime expected = buildDate(2016, 9, 15, 17, 0);
		LocalDateTime start = buildDate(2016, 9, 15, 15, 0);
		LocalDateTime date = DateParser.determineEndDate(dateString, start);
		assertEquals(expected, date);
	}
	
	@Test
	public void testDateWithTime() {
		String dateString = "15/9/16 5pm";
		LocalDateTime expected = buildDate(2016, 9, 15, 17, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testDayOffsetWithTime() {
		String dateString = "tomorrow 5pm";
		LocalDateTime expected = buildDate(1, 17, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testDayWithTime() {
		String dateString = "monday 5pm";
		LocalDateTime expected = buildDateWithNextDay(1, 17, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testTimeIsNow() {
		String dateString = "now";
		LocalDateTime expected = LocalDateTime.now();
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertTrue(approximatelyEqual(expected, date));
	}
	
	@Test
	public void testUppercaseDate() {
		String dateString = "TomoRRoW 5pm";
		LocalDateTime expected = buildDate(1, 17, 0);
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertEquals(expected, date);
	}
	
	@Test
	public void testImpossibleDate() {
		String dateString = "15/15/15";
		LocalDateTime date = DateParser.determineStartDate(dateString);
		assertNull(date);
	}
	

	private LocalDateTime buildDate(int daysOffsetFromNow, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.now();
		date = date.plusDays(daysOffsetFromNow).withHour(hours).withMinute(minutes).withSecond(0).withNano(0);
		return date;
	}

	// day: 0 -> sunday, 1 -> monday, ..., 6 -> saturday
	private LocalDateTime buildDateWithNextDay(int day, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.now();
		int diff = (day - date.getDayOfWeek().getValue());
		if (diff < 0) {
			diff += 7;
		}
		date = date.plusDays(diff).withHour(hours).withMinute(minutes).withSecond(0).withNano(0);
		return date;
	}

	private LocalDateTime buildDate(int year, int month, int day, int hours, int minutes) {
		LocalDateTime date = LocalDateTime.of(year, month, day, hours, minutes).withSecond(0).withNano(0);
		return date;
	}
	
	private boolean approximatelyEqual(LocalDateTime date1, LocalDateTime date2) {
		int difference = date1.compareTo(date2);
		return (difference < 1000 || difference > -1000);
	}
}
```
###### src\tests\integration\IntegrationTest.java
``` java
	@Test
	public void integrationTest() throws Exception {
		String prevStorageLocation = AppStorage.getInstance().getStorageFileLocation();
		AppStorage.getInstance().setStorageFileLocation("testStorage/integration1.txt");
		File testFile = createTestFile();
		
		String[] commands = {
			"add 1st task", 
			"add 2nd task",
			"add 3rd task",
			"add 4th task",
			"edit 1 priority high",
			"mark 2 3",
			"display completed",
			"delete 1",
			"exit"
		};
		
		/* Final result:
		 * 1st task (priority high)
		 * 3rd task (completed)
		 * 4th task
		 */
		try {
			Main.main(commands);
			List<Task> tasks = TaskStorage.getInstance().readTasks().getTaskList();
			assertEquals(3, tasks.size());
			assertEquals(Priority.HIGH, tasks.get(0).getPriority());
			assertTrue(tasks.get(1).isCompleted());
			assertEquals("4th task", tasks.get(2).getName());
		} catch (Exception e) {
			throw e; // JUnit will handle this and report a failed assertion
		} finally {
			removeFileAndParentsIfEmpty(testFile.toPath());
			AppStorage.getInstance().setStorageFileLocation(prevStorageLocation);
		}

	}

```
