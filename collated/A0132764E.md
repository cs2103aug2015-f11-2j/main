# A0132764E
###### src\app\constants\CommandConstants.java
``` java
	// Aliases for commands
	public static final List<String> ALIASES_ADD = Common.getUnmodifiableList("add", "a", "+");
	public static final List<String> ALIASES_DELETE = Common.getUnmodifiableList("delete", "del", "d", "remove", "rm", "-");
	public static final List<String> ALIASES_HELP = Common.getUnmodifiableList("help", "?" , "h");
	public static final List<String> ALIASES_THEME = Common.getUnmodifiableList("theme", "t");
	public static final List<String> ALIASES_EXIT = Common.getUnmodifiableList("exit", "quit");
	public static final List<String> ALIASES_MARK = Common.getUnmodifiableList("mark", "m");
	public static final List<String> ALIASES_DISPLAY = Common.getUnmodifiableList("display", "show", "view", "v");
	public static final List<String> ALIASES_EDIT = Common.getUnmodifiableList("edit", "modify", "change", "update", "e");
	public static final List<String> ALIASES_SEARCH = Common.getUnmodifiableList("search", "s");
	public static final List<String> ALIASES_SAVE = Common.getUnmodifiableList("save");
	public static final List<String> ALIASES_UNDO = Common.getUnmodifiableList("undo", "u");

	// Enum values for the different types of commands
	public enum CommandType {
		ADD, DELETE, SEARCH, EXIT, HELP, THEME, INVALID, MARK, DISPLAY, EDIT, SAVE, UNDO;
	}
}
```
###### src\app\constants\ViewConstants.java
``` java
	// SEARCH command
	public static String ERROR_SEARCH_NO_PARAMETER = "No search parameters specified";
	public static String HEADER_SEARCH = "Search results";
	public static String MESSAGE_SEARCH = "%d match(es)";
	public static String ERROR_SEARCH = "Error";

```
###### src\app\logic\command\CommandSearch.java
``` java
	public CommandSearch() {
		super();
		this.setCommandType(CommandType.SEARCH);
	}
	
```
###### src\app\logic\command\CommandSearch.java
``` java
	@Override
	public ViewState execute(ViewState previousViewState) {
		LogHelper.getInstance().getLogger().info("Executing CommandSearch object.");

		this.previousViewState = new ViewState(previousViewState);
		ViewState viewState = new ViewState();
		TaskList master = CommandController.getInstance().getMasterTaskList();
		TaskList retrievedTaskList = master.getTaskListByCompletion(false);

		LogHelper.getInstance().getLogger()
				.info("\nContent: " + this.getContent() + "\nPriority: " + this.getPriority() + "\nStart: "
						+ this.getStartDate() + "\nEnd: " + this.getEndDate() + "\nType: " + this.getDisplayType());

		try {
			if (this.getDisplayType() == DisplayType.ALL) {
				retrievedTaskList = master;
			} else if (this.getDisplayType() == DisplayType.COMPLETED) {
				retrievedTaskList = master.getTaskListByCompletion(true);
			} 

			List<Predicate<Task>> predicates = new ArrayList<Predicate<Task>>();
			if (!this.getContent().isEmpty()) {
				predicates.add(Predicates.keywordMatches(this.getContent()));
			}
			if (this.getPriority() != null) {
				predicates.add(Predicates.priorityEquals(this.getPriority()));
			}
			if (this.getStartDate() != null && this.getEndDate() != null) {
				predicates.add(Predicates.betweenDates(this.getStartDate(), this.getEndDate()));
			} 
			else if (this.getEndDate() != null) {
					predicates.add(Predicates.endDateBefore(this.getEndDate()));
			} 
			else if (this.getStartDate() != null) {
					predicates.add(Predicates.startDateAfter(this.getStartDate()));
			}
			if (this.floatSearch()) {
				predicates.add(Predicates.floatingTask());
			}

			TaskList results = retrievedTaskList.search(predicates);
			viewState.setTaskList(results);
			viewState.setHeader(ViewConstants.HEADER_SEARCH);
			
			viewState.setStatus(StatusType.SUCCESS,
					String.format(ViewConstants.MESSAGE_SEARCH, results.getTaskList().size()));
			
			if (predicates.isEmpty() && this.getDisplayType() == null){
				viewState.setStatus(StatusType.SUCCESS,ViewConstants.ERROR_SEARCH_NO_PARAMETER);
				return viewState;
			}
			this.setExecuted(true);
		} catch (Exception e) {
			LogHelper.getInstance().getLogger().severe("Error: "+e.getMessage());
			viewState.setStatus(StatusType.ERROR, String.format(ViewConstants.ERROR_SEARCH, this.getContent()));
		}
		
		return viewState;
	}
	
```
###### src\app\logic\CommandController.java
``` java
	private static CommandController commandController;

	private TaskList masterTaskList;
	private ViewState currentViewState;
	private Stack<Command> executedCommands;
	
	private CommandList commandHistory;

	private CommandController() {
		masterTaskList = TaskStorage.getInstance().readTasks();
		executedCommands = new Stack<Command>();
		commandHistory = new CommandList();
		initializeViewState();
	}
	

	private void initializeViewState() {
		currentViewState = new ViewState();
		currentViewState.setTaskList(masterTaskList.getTaskListByCompletion(false));
		currentViewState.getTaskList().sort();
		currentViewState.setHeader(String.format(ViewConstants.HEADER_DISPLAY,
				DisplayType.UNCOMPLETED.toString()));

		if (!(AppStorage.getInstance().getSelectedTheme().equalsIgnoreCase(ViewConstants.THEME_LIGHT)
				|| AppStorage.getInstance().getSelectedTheme().equalsIgnoreCase(ViewConstants.THEME_DARK))) {
			AppStorage.getInstance().setToDefaultSelectedTheme();
		}
		
		if (AppStorage.getInstance().getSelectedTheme().equalsIgnoreCase(ViewConstants.THEME_LIGHT)) {
			currentViewState.setTheme(ViewConstants.THEME_LIGHT_CSS);
		} else if (AppStorage.getInstance().getSelectedTheme().equalsIgnoreCase(ViewConstants.THEME_DARK)) {
			currentViewState.setTheme(ViewConstants.THEME_DARK_CSS);
		}
	}

	/**
	 * This method implements the Singleton design pattern.
	 * 
	 * @return This instance of CommandController.
	 */

	public static CommandController getInstance() {
		if (commandController == null) {
			commandController = new CommandController();
		}
		return commandController;
	}

	/**
	 * Entry method for executing a command string. The command string is parsed
	 * and the relevant logic is executed.
	 * 
	 * @param commandString The full command string.
	 */
	public ViewState executeCommand(String commandString) {
		commandString = commandString.trim();
		Command cmd = createCommand(commandString);
				
		ViewState newViewState = cmd.execute(currentViewState);
		commandHistory.add(cmd.getCommandString());

		if (cmd.isExecuted()) {
			currentViewState.mergeWith(newViewState);
			currentViewState.getTaskList().sort();
			if (cmd.getCommandType() != CommandType.UNDO) {
				executedCommands.push(cmd); 
			}
		} else {
			// If not executed, simply update status bar and reset actions.
			currentViewState.mergeStatus(newViewState);
			currentViewState.setActions(new ArrayList<Action>());
		}
		
		return currentViewState;
	}

	/**
	 * Determines the CommandType of the specified command string
	 * 
	 * @param commandString The command string
	 * @return The determined CommandType object
	 */
	private CommandType determineCommandType(String commandString) {
		String word = Common.getFirstWord(commandString).toLowerCase();
		if (CommandConstants.ALIASES_ADD.contains(word)) {
			return CommandType.ADD;
		} else if (CommandConstants.ALIASES_DELETE.contains(word)) {
			return CommandType.DELETE;
		} else if (CommandConstants.ALIASES_THEME.contains(word)) {
			return CommandType.THEME;
		} else if (CommandConstants.ALIASES_HELP.contains(word)) {
			return CommandType.HELP;
		} else if (CommandConstants.ALIASES_MARK.contains(word)) {
			return CommandType.MARK;
		} else if (CommandConstants.ALIASES_DISPLAY.contains(word)) {
			return CommandType.DISPLAY;
		} else if (CommandConstants.ALIASES_EDIT.contains(word)) {
			return CommandType.EDIT;
		} else if (CommandConstants.ALIASES_SAVE.contains(word)) {
			return CommandType.SAVE;
		} else if (CommandConstants.ALIASES_SEARCH.contains(word)) {
			return CommandType.SEARCH;
		} else if (CommandConstants.ALIASES_UNDO.contains(word)) {
			return CommandType.UNDO;
		}  else if (CommandConstants.ALIASES_EXIT.contains(word)) {
			return CommandType.EXIT;
		}
		return CommandType.INVALID;
	}

	/**
	 * Creates the relevant Command subclass based on the CommandType parsed
	 * from the supplied input parameter. Also based on the CommandType, the
	 * created Command subclass is then parsed appropriately. The result is a
	 * Command object with all its fields populated based on the input
	 * parameter.
	 * 
	 * @param commandString The command string
	 * @return A Command subclass with its fields set to the parsed result
	 */
	public Command createCommand(String commandString) {
		CommandType commandType = determineCommandType(commandString);
		Command cmd;

		switch (commandType) {
		case ADD:
			cmd = new CommandAdd();
			break;
		case THEME:
			cmd = new CommandTheme();
			break;
		case MARK:
			cmd = new CommandMark();
			break;
		case DELETE:
			cmd = new CommandDelete();
			break;
		case DISPLAY:
			cmd = new CommandDisplay();
			break;
		case EDIT:
			cmd = new CommandEdit();
			break;
		case SAVE:
			cmd = new CommandSave();
			break;
		case UNDO:
			cmd = new CommandUndo();
			break;
		case SEARCH:
			cmd = new CommandSearch();
			break;
		case HELP:
			cmd = new CommandHelp();
			break;
		case EXIT:
			cmd = new CommandExit();
			break;
		case INVALID: // Intentional fall-through and default case
		default:
			cmd = new CommandInvalid();
		}

		cmd.setCommandString(commandString);
		cmd.setContent(Common.removeFirstWord(cmd.getCommandString()));
		parseCommand(cmd);
		return cmd;
	}

	/**
	 * Parses the supplied Command object based on its CommandType.
	 * 
	 * @param cmd The object to parse
	 */
	private void parseCommand(Command cmd) {
		// Additional parsing for certain command types
		switch (cmd.getCommandType()) {
		case ADD:
			CommandParser.parseDatesAndPriority(cmd);
			break;
		case DISPLAY:
			cmd.setContent(CommandParser.determineDisplayType(cmd.getContent()).toString());
			break;
		case EDIT:
			CommandParser.parseDatesAndPriority(cmd, true);
			CommandEdit e = (CommandEdit) cmd;
			e.setDisplayId(CommandParser.getTaskDisplayedIdFromContent(cmd.getContent()));
			e.setContent(CommandParser.getTaskDescFromContent(cmd.getContent()));
			break;
		case SAVE:
			CommandParser.parseSave(cmd);
			break;
		case SEARCH:
			CommandParser.parseSearch(cmd);
			break;
		case MARK:
			cmd.setContent(CommandParser.determineMarkAll(cmd.getContent()).toString());
			break;
		default:
			break;
		}
	}

	public TaskList getMasterTaskList() {
		return masterTaskList;
	}

	public ViewState getCurrentViewState() {
		return currentViewState;
	}
	
	public CommandList getCommandHistory() {
		return commandHistory;
	}

	public Stack<Command> getExecutedCommands() {
		return executedCommands;
	}
}
```
###### src\app\model\CommandList.java
``` java
public class CommandList {
	ArrayList<String> commandList;
	int index;

	public CommandList() {
		commandList = new ArrayList<String>();
		index = -1;
	}
	
	public void add(String cmd) {
		commandList.add(cmd);
		reset();
	}
	
	//decrements index and returns command (String)
	public String prev() {
		index--;
		if (isValidIndex(index)) {
			return commandList.get(index);
		} else {
			index = 0;
			return "";
		}
	}
	
	public String next() {
		index++;
		if (isValidIndex(index)) {
			return commandList.get(index);
		} else {
			index = commandList.size();
			return "";
		}
	}
	
	public void reset() {
		index = commandList.size();
	}
	
	private boolean isValidIndex(int index) {
		return (index >= 0 && index < commandList.size());
	}
}
```
###### src\app\model\TaskList.java
``` java
	public TaskList search(List<Predicate<Task>> predicates) {
		Predicate<Task> query = compositePredicate(predicates);
		TaskList results = new TaskList();
		
		// filter the task list using the predicates
		// for each result, add it to the results list
		taskList.stream().filter(query).forEach(t -> results.addTask(t));
		return results;
	}

```
###### src\app\model\TaskList.java
``` java
	private Predicate<Task> compositePredicate(List<Predicate<Task>> predicates) {
		return predicates.stream().reduce(t -> true, Predicate::and);
	}
}
```
###### src\app\util\Predicates.java
``` java
	/**
	 * Predicate<Task> for specified end before date
	 * 
	 * @param end The end time used for match
	 * @return Predicate<Task> that ends before specified date
	 */
	public static Predicate<Task> endDateBefore(LocalDateTime end) {
		return t -> (t.getEndDate() != null) ? (t.getEndDate().isBefore(end) || t.getEndDate().isEqual(end)) : false;
	}
	
```
###### src\app\util\Predicates.java
``` java
	/**
	 * Predicate<Task> for specified start after date
	 * 
	 * @param start The start time used for match
	 * @return Predicate<Task> that starts after specified date
	 */
	public static Predicate<Task> startDateAfter(LocalDateTime start) {
		return t -> (t.getEndDate() != null) ? (t.getEndDate().isAfter(start) || t.getEndDate().isEqual(start)) : false;
	}

```
###### src\app\util\Predicates.java
``` java
	/**
	 * Predicate<Task> for specified start and end time
	 * 
	 * @param start The start time of task 
	 * @param end The end time of task 
	 * @return Predicate<Task> that falls between specified start and end dates
	 */
	public static Predicate<Task> betweenDates(LocalDateTime start, LocalDateTime end) {
		return t -> (t.getStartDate() != null
				|| t.getEndDate() != null)
						? (((t.getStartDate() != null)
								? (t.getStartDate().isEqual(start) || t.getStartDate().isAfter(start))
								: true)
								&& ((t.getEndDate() != null)
										? (t.getEndDate().isEqual(end)
												|| (t.getEndDate().isBefore(end) && t.getEndDate().isAfter(start)))
										: true))
						: false;

	}

```
###### src\app\util\Predicates.java
``` java
	/**
	 * Predicate<Task> for specified priority
	 * 
	 * @param priority The Priority used for match
	 * @return Predicate<Task> with specified priority
	 */
	public static Predicate<Task> priorityEquals(Priority priority) {
		return t -> (t.getPriority() != null)
				? (t.getPriority().toString().toLowerCase().equalsIgnoreCase(priority.toString().toLowerCase()))
				: false;
	}

```
###### src\app\util\Predicates.java
``` java
	/**
	 * Predicate<Task> for keyword matches
	 * 
	 * @param keyword The keyword used for match
	 * @return Predicate<Task> with specified keyword
	 */
	public static Predicate<Task> keywordMatches(String keyword) {
		// return t -> t.getName().toLowerCase().matches(".*\\b" +
		// keyword.toLowerCase() + "\\b.*");
		return t -> t.getName().toLowerCase().contains(keyword.toLowerCase());
	}
	
```
###### src\app\util\Predicates.java
``` java
	/**
	 * Predicate<Task> for nil start date and end date
	 * 
	 * @param nil
	 * @return Predicate<Task> with no start and end dates (floating tasks)
	 */
	public static Predicate<Task> floatingTask() {
		return t -> t.isFloating();
	}
}
```
###### src\tests\PredicatesTest.java
``` java
	@Test
	public void testPredicates() {
		//building test environment
		TaskList list = new TaskList();
		assertTrue(list.getTaskList().isEmpty());
		String input = "add eat sandwich";
		Command cmd = CommandController.getInstance().createCommand(input);
		Task task = new Task(cmd);
		list.addTask(task);
		
		input = "add eat hotdog by 6/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		task = new Task(cmd);
		list.addTask(task);
		
		input = "add eat salad from 1/11/15 to 4/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		task = new Task(cmd);
		list.addTask(task);
		
		input = "add CS2103 presentation priority high";
		cmd = CommandController.getInstance().createCommand(input);
		task = new Task(cmd);
		list.addTask(task);
		
		TaskStorage.getInstance().writeTasks(list);
		TaskList master = CommandController.getInstance().getMasterTaskList();
		TaskList retrievedTaskList = master.getTaskListByCompletion(false);
		
		//Start test on search function
		List<Predicate<Task>> predicates = new ArrayList<Predicate<Task>>();
		assertTrue(predicates.isEmpty());
		
		//single parameter search test cases
		input = "search eat";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.keywordMatches(cmd.getContent()));
		assertFalse(predicates.isEmpty());
		TaskList results = retrievedTaskList.search(predicates);
		assertEquals(3, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search vegetables";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.keywordMatches(cmd.getContent()));
		assertFalse(predicates.isEmpty());
		results = retrievedTaskList.search(predicates);
		assertEquals(0, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search between 1/11/15 and 7/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.betweenDates(cmd.getStartDate(), cmd.getEndDate()));
		assertFalse(predicates.isEmpty());
		results = retrievedTaskList.search(predicates);
		assertEquals(2, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search after 5/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.startDateAfter(cmd.getStartDate()));
		assertFalse(predicates.isEmpty());
		results = retrievedTaskList.search(predicates);
		assertEquals(1, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search before 5/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.endDateBefore(cmd.getEndDate()));
		assertFalse(predicates.isEmpty());
		results = retrievedTaskList.search(predicates);
		assertEquals(1, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search priority high";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.priorityEquals(cmd.getPriority()));
		assertFalse(predicates.isEmpty());
		results = retrievedTaskList.search(predicates);
		assertEquals(1, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search priority none";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.priorityEquals(cmd.getPriority()));
		assertFalse(predicates.isEmpty());
		results = retrievedTaskList.search(predicates);
		assertEquals(3, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		
		//multiple parameter search test cases
		
		input = "search eat before 4/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.keywordMatches(cmd.getContent()));
		results = retrievedTaskList.search(predicates);
		assertFalse(results.getTaskList().size() == 1);
		predicates.add(Predicates.endDateBefore(cmd.getEndDate()));
		results = retrievedTaskList.search(predicates);
		assertTrue(results.getTaskList().size() == 1);
		results = retrievedTaskList.search(predicates);
		assertEquals(1, results.getTaskList().size());
		predicates = new ArrayList<Predicate<Task>>();
		
		input = "search eat priority none after 4/11/15";
		cmd = CommandController.getInstance().createCommand(input);
		predicates.add(Predicates.keywordMatches(cmd.getContent()));
		predicates.add(Predicates.priorityEquals(cmd.getPriority()));
		predicates.add(Predicates.startDateAfter(cmd.getStartDate()));
		results = retrievedTaskList.search(predicates);
		assertTrue(results.getTaskList().size() == 2);
		
	}
}
```
